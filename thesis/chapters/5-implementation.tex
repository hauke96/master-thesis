% !TEX root = ../thesis.tex
% !TeX spellcheck = en_US

This section covers details on the implementation of the previously described design.
First, an overview of the algorithm is given including a short description of used frameworks and technologies.
Second, two new and important data structures are described in detail.
Finally, each algorithmic step of the graph generation but also of the query answering is described in the main sections of this chapter.

\section{Algorithm overview}

	In this section, details on the code dependencies are given as well as a broad overview of the algorithm.

	\subsection{Frameworks and technology}
	\label{subsec:frameworks-technology}
	
		As mentioned in \Cref{subsec:constraints} about the constraints, the used programming language is C\# due to the dependency to the MARS framework.
		The MARS framework is based on the widely used C\# library \term{NetTopologySuite} (\term*{NTS}), which contains numerous data structures, algorithms and helper function to handle and process geospatial data.
		
		Primarily, the NTS was used for basic data structures like coordinates, geometries and features but also for simple operations, e.g. the calculation of distances.
		Writing data to files is also done with the help of the NTS, namely to serialize the geospatial data into the GeoJSON format.
		
		The \term*{MARS} framework was also used for basic data structures, for example the \texttt{Position} class.
		However, higher level structures were used as well, such as \texttt{SpatialGraph} or \texttt{QuadTree} classes.
		
		Not all data structures and algorithms already existed to create the hybrid routing graph.
		Most notably, a \hyperref[subsubsec:intersection-checks]{fast line intersection check}, a \hyperref[subsec:binindex]{bin-based index} and a fast \hyperref[subsec:shadow-areas]{vertex filtering method} were implemented.
		The latter one refers to the so-called \emph{shadow areas} in the sections below.
		Several other helper functions and simpler structures, for instance separate classes for vertices and obstacles, were added as well.
	
%	\subsection{Chosen approach and potentially faster known algorithms}
%
%		Due to the step by step development by turning the former continuous dijkstra preprocessing into a visibility graph generator, the implemented approach does not follow algorithms described in the literature.
%		The performance of this implementation, as shown in \todo[inline]{link to evaluation chapter}, is still enough for practical use, but a well designed and fast algorithm, like the one presented by Overmars and Welzl\cite{overmars-weizl-visibility-graph} or the one by Ghosh and Mount\cite{ghosh-output-sensitive-vgraph}, would clearly increase performance.
%		However, this performance enhancement would only affect the generation of a visibility graph and not the performance of the routing queries.
			
	\subsection{Algorithm steps}
	\label{subsec:algorithm-steps}
	
		In the following, the main steps of the two parts of this algorithm are outlined:
		The graph generation and the answering of routing requests.
		
		\subsubsection{Graph generation}
		\label{subsubsec:graph-generation}
		
			The \texttt{HybridVisibilityGraphGenerator} class provides a factory method to create an instance of the \texttt{HybridVisibilityGraph} class from a given collection of features.
			This factory method consists of the following top level steps, which are all described in \Cref{sec:visibility-graph-creation} in more detail:
			\begin{enumerate}
				\item \hyperref[subsec:step-1-preprocessing]{Filter the given features for obstacles}
				\item \hyperref[subsec:step-2-knn-search]{Determine the visibility neighbors}
				\item \hyperref[subsec:step-3-graph-creation]{Use this visibility relation to create a visibility graph}
				\item \hyperref[subsec:step-4-graph merging]{Merge the existing road network into this graph}
			\end{enumerate}
			The resulting hybrid visibility graph then allows to route between existing nodes.
			So far, routing queries between arbitrary locations cannot be answered, only between existing nodes.
			Handling arbitrary location is part of the next step.
		
		\subsubsection{Answering routing queries}
		
			To enable answering routing requests between arbitrary locations the resulting graph needs to be extended with edges from and to the given start and end locations.
			These edges themselves are visibility edges and can therefore be created and merged just like the visibility edges before.
			Further details are given in \Cref{sec:answering-queries} describing the following steps:
			\begin{enumerate}
				\item Determine visibility edges for source and destination coordinates\label{itm:step-merging-source-dest}
				\item Merge these edges into the graph such that they can be removed afterwards
				\item Route along the resulting graph (e.g. by using the A* algorithm)
				\item Restore the original graph by removing all nodes and edges added in step \ref{itm:step-merging-source-dest}
			\end{enumerate}
			The last step ensures that subsequent routing queries are answered based on the original graph and not on an altered version of it.
			It also prevents an uncontrolled growth of the graph.
	
\section{Data structures}
	
	Before the separate steps of the graph generation are described in detail, the newly created data structures are presented.
		
	\subsection{Shadow areas}
	\label{subsec:shadow-areas}
		
		Shadow areas are a method I designed and implemented to quickly determine and filter out vertices that are not visible to each other.
		The motivation and the idea behind shadow areas is the following:
		Having a light bulb as a single light source, everything within a shadow is not visible from that light bulb.
		Interpreting a vertex $v$ as a light bulb illuminating its surroundings, an obstacle $o$ casts a shadow outwards and every vertex within this shadow is definitely not visible from $v$.
		
		Each shadow is determined by three values: two values for the angular range (also referred to as \emph{angle area}) and a third value for the minimum distance from which other vertices within the angular range are definitely not visible.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\angle{20}
					\def\boundingVertexDistance{3}
					
					\tikzDot[label=$v$]{(0,1.5)}{v}
					\coordinate (shadow-arc-top)				at ($(v) +( \angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-bottom)				at ($(v) +(-\angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-top-end)			at ($(v) +( \angle:5.75)$);
					\coordinate (shadow-arc-bottom-end)			at ($(v) +(-\angle:5.75)$);
					\coordinate (shadow-arc-top-faded-end)		at ($(v) +( \angle:6.5)$);
					\coordinate (shadow-arc-bottom-faded-end)	at ($(v) +(-\angle:6.5)$);
					
					% Gray area
					\filldraw[lightgray] 
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					cycle;
					\draw[gray]
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end);
					
					\draw[dotted] (v) -- (shadow-arc-top);
					\draw[dotted] (v) -- (shadow-arc-bottom);
					
					% Faded gray area
					\filldraw[draw=none,lightgray,path fading=east]
					(shadow-arc-top-faded-end) --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom-faded-end) --
					cycle;
					\draw[gray,path fading=east] (shadow-arc-top-end) -- (shadow-arc-top-faded-end);
					\draw[gray,path fading=east] (shadow-arc-bottom-end) -- (shadow-arc-bottom-faded-end);
					
					% Obstacle
					\tikzDot[red]{(shadow-arc-top)}{o0}
					\tikzDot{(3.8,2)}{o1}
					\tikzDot[red]{($(v) +(-\angle:1.2)$)}{o2}
					\node[above right = 0.5 and 1.15 of o2] {$o$};
					
					% v' and v''
					\tikzDot[label=right:$v'$]{(2.1,1.1)}{v'}
					\tikzDot[label=right:$v''$]{(3.4,1.3)}{v''}
					
					\node[darkgray] at (4.7,1.5) {\huge$S$};
					
					\draw (o0) -- (o1) -- (o2) -- (o0);
				\end{tikzpicture}
			\end{figcenter}
			\caption{Shadow area $S$ cast by obstacle $o$ seen from vertex $v$. The two red vertices of obstacle $o$ are the bounding vertices determining angular range and distance of $S$. The vertex $v''$ is not visible from $v$ since it lies inside the shadow area. Note that $v'$ is not visible either even though it is not inside the shadow area.}
			\label{fig:shadow-area}
		\end{figure}
		
		The angular range is determined by two vertices, the \emph{bounding vertices} as marked in red in \Cref{fig:shadow-area}, one with the smallest and one with the largest angle from the processed vertex $v$.
		Thus, the shadow area covers the largest possible angular range for the obstacle it belongs to.
		
		Having the distances from $v$ the two bounding vertices, the larger distance is the overall distance of the shadow area.
		Choosing any other distance, e.g. the smaller distance of these two, would result in a shadow area leading to false positive visibility checks, meaning the checked vertex is within the shadow but it is actually visible from $v$.
		Taking the larger distance into account results in false negative results (as for $v'$ in \Cref{fig:shadow-area}), meaning the vertex is not within a shadow but not visible, which can be handled by a full visibility check.
		Additionally when using the larger distance, positive results, meaning the checked vertex is within a shadow and seems to be not visible from $v$, are always true positive results and need no further checking.
		
		Calculating the shadow area of an obstacle is a linear time operation (linear in the amount of vertices of the obstacle) and requires just a few arithmetic operations.
		
		For example for the currently processed vertex $v$, a shadow area can range from 45° to 90° and starts at a distance of 5 meters.
		This means a vertex at 60° and 3 meters distance might be visible from $v$ but a visibility check is needed.
		A vertex at 60° and 6 meters distance is definitely not visible.
		This scenario is illustrated in \Cref{fig:shadow-area} with vertices $v'$ and $v''$.
		
		In terms of data structures, each shadow is an interval (between 0 and 360) of certain distance, which turns the visibility problem into an interval intersection problem.
		Thus, checking whether a certain coordinate is within any shadow area is a simple operation using just a few arithmetic operations.
		
		Keeping track of these shadow areas for each vertex significantly improves performance, especially with the use of the \texttt{BinIndex} data structure described \hyperref[subsec:binindex]{below}.
		\todo[inline]{Evaluation why this is fast.}
		
		% NetworkRoutingPlayground->Jungfernstieg dataset with 7916 vertices: ~7.3s with and 67s without shadow areas -> speedup of factor ~9
		% Hamburg inner city dataset with 67819 vertices: 382s with and ~31000s without shadow areas -> speedup of factor ~81
		
	\subsection{BinIndex data structure}
	\label{subsec:binindex}
		
		The \texttt{BinIndex} class implements a linear bin-based index structure to store and access intervals.
		It contains $n$ many bins covering a certain range and each bin consists of a linked list.
		Items are added to each bin that intersect with the range of the item.
		Due to the linked list as the underlying data structure for the bins, point queries can be answered in constant and range queries in linear time.
		However, range queries are not needed within the scope of this work, so they are not implemented.
		\Cref{fig:bin-index} illustrates this data structure with a simple example.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\l{0.5}
					\def\countX{9} % One more is added due to start at x=0
					\def\countY{1} % One more is added due to start at x=0
					
					\def\itemBStartX{1.6}
					\def\itemBIndexStart{1}
					\def\itemBLength{4.1}
					
					\def\itemAStartX{4}
					\def\itemAIndexStart{4}
					\def\itemALength{7.8}
					
					% Item A: Bins 1-5
					\draw[dotted,gray] (\itemBStartX*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\draw[dotted,gray] (\itemBStartX*\l+\itemBLength*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\filldraw[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBStartX*\l,\countY+4*\l) rectangle node[above right=0.125 and -1.3]{Item B: \itemBStartX\ - 5.7} ++(\itemBLength*\l,0.5*\l);
					
					% Item B: Bins 4-11(2)
					\draw[dotted,gray] (\itemAStartX*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\draw[dotted,gray] (\itemAStartX*\l+\itemALength*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\filldraw[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAStartX*\l,\countY+3*\l) rectangle node[above right=0.125 and -0.5]{Item A: \itemAStartX\ - 10.8} ++(\itemALength*\l,0.5*\l);
					
					\draw[->] (\itemAStartX*\l+1.85,\countY+2.75*\l) -- node[right] {1.} +(0,-1.5*\l);
					\draw[->] (\itemBStartX*\l+0.5,\countY+3.75*\l) -- node[right] {2.} +(0,-2.5*\l);
					
					% Draw pattern to bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+1*\l,0) rectangle ++(2*\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAIndexStart*\l,0) rectangle ++(6*\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (0,0) rectangle ++(2*\l,\l);
					
					% Draw gray versions of filled bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=lightgray] (\l*\countX+\l+\itemBIndexStart*\l+1*\l,0) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=lightgray] (\l*\countX+\l,0) rectangle ++(2*\l,\l);
					
					% Draw outlines of repeating gray bins
					\foreach \x in {0,...,2}
					{
						\draw[lightgray] (\l*\countX+\l+\l*\x,0) rectangle ++(\l,\l);
						\node[lightgray] at (\l*\countX+\l+\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					% Draw outlines of bins
					\foreach \x in {0,...,\countX}
					{
						\draw (\l*\x,0) rectangle ++(\l,\l);
						\node at (\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					\draw (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+0.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+3.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+4.5*\l,\l) -- ++(0,0.5*\l);
					
					\node at (0.5*\countX*\l,-0.875) {bins};
					\node[align=right] at (-1.25,0.5*\countY*\l+0.5*\l) {Linked lists\\of bins};
				\end{tikzpicture}
			\end{figcenter}
			\caption{Bin index filled with two items A (added first) and B (added last). Since item A was added first, B's entries in, which fall into a bin where en entry for item A already exists, are moved to a next item in the linked list of the bin. Each bin covers a range, which means non integer value are rounded down (for from-values) or up (for to-values).}
			\label{fig:bin-index}
		\end{figure}
		
		The NetTopologySuite offers several indices specifically made for intervals, namely the \texttt{BinTree}, \texttt{SIRtree} and \texttt{SortedPackedIntervalRTree}, of which only the first one is dynamic and thus allows insertions and deletions after the first query was made.
		This dynamic behavior is crucial for an efficient use of the shadow areas.
		Otherwise, the shadow areas must be created in beforehand, added to and index and then be used, which results in a large number of unnecessary areas being added to the index.
		
		Even though these three data structures are tree-based and offer a logarithmic query time complexity for queries, compared to the linear time complexity of the \texttt{BinIndex}, the simple and list-based \texttt{BinIndex} is significantly faster even for larger datasets with tens of thousands of vertices.
		%It is thinkable that the logarithmic complexity is useful for even larger datasets with millions of vertices.
		\todo[inline]{Measure performance + Point when the tree is better}
		
\section{Routing graph creation}
\label{sec:visibility-graph-creation}
		
	This section presents implementation details on the steps given in \Cref{subsubsec:graph-generation} for graph generation, which includes generating a visibility graph and merging it with a road network.

	\subsection{Step 1: Obstacle filtering and feature preprocessing}
	\label{subsec:step-1-preprocessing}
			
		The first step is to filter all input features by their attributes to get all relevant obstacle features, regardless of their geometry.
		
		For performance reasons, multi-geometries, like \texttt{MultiPolygon} are split up into their separate geometries.
		% TODO Add remarks on handling islands in multi-polygons (s. ticket).
		%Holes in a polygon are not reachable in the first place and unwrapping the \texttt{MultiPolygon} will not change this.
		Unwrapping \texttt{MultiLineString} geometries is unproblematic as well, since the result are just multiple normal linestrings.
		Features made of \texttt{Point} geometries are also considered so that visibility edges can reach \term*{points of interest}.
		Visibility checks, which are performed in the next step of the algorithm, can ignore point features, since they have no spatial size.
		
		Another task within this first step is the triangulation of all polygonal shapes, which happens during the unwrapping of multi geometries.
		The main reason is a better performance for intersection checks, which is an important operation when checking if an obstacle is between two vertices.
		Details on the intersection check implementation are given \hyperref[subsubsec:intersection-checks]{below}.
		
		Also worth mentioning is the determination of each obstacles' convex hull.
		Of course this is not a complex task, since all obstacles are either triangles (due to the triangulation), linestrings or points.
		As described \hyperref[subsubsec:convex-hull]{below}, only vertices on the convex hull of obstacles will be considered in the further processing, which is a simple performance enhancement.
			
	\subsection{Step 2: Determining $k$ nearest visible neighbors}
	\label{subsec:step-2-knn-search}
			
		This step performs the main task of the visibility graph creation, namely the determination of all $k$ many visible neighbors for each vertex.
%		Determining not only $k$ but all visible neighbors would also be possible, but the parameter $k$ is an easy way to increase performance with the downside of not having all possible edges in the final routing graph.
%		The fact of potential suboptimal routes is discussed in the following.
		Before the actual algorithm is presented, some concepts and optimizations are described to understand the implemented algorithm.
		Then an overview of the performed steps is given followed by details on each of these steps.
		
		\subsubsection{Terminology}
		
			Before describing the details on determining the $k$ nearest neighbors, there are some terms that need to be defined.
			
			\begin{description}
				\item[obstacle] An \term{obstacle} is a geometry that should be avoided when determining shortest paths. It can be any type of geometry, not only a polygon.
				\item[visibility neighbor] A \term{visibility neighbor} (sometimes also \emph{visible neighbor}) of a vertex $v$ is another vertex $u$, which is visible to $v$ and vice versa. In other words an imaginary linestring from $v$ to $u$ does not intersect with any obstacle.
				\item[obstacle neighbor] An \term{obstacle neighbor} of a vertex $v$ is another vertex $u$ with the property that an (undirected) edge $\{v, u\}$ exists on that obstacle. In other words, $u$ is visible from $v$ but not via a visibility edge but instead via an edge of that obstacle.
				\item[valid angle area] A \term{valid angle area} describes a specially determined angular range around a vertex in which potential visibility neighbors are checked.
			\end{description}
		
		\subsubsection{Parameter $k$ and consequences on the shortest paths}
		
			The $k$, however, is not just a single parameter, but rather a tuple of two separate values:
			The number of bins $k_b$ and the number of maximum neighbors per bin $k_n$.
			This means a maximum of $k_b \cdot k_n$ many neighbors are considered.
			
			Each bin covers a certain angle area of the currently processed vertex, for example for a bin count of 36, each bin would cover a 10° area.
			In fact, the chosen default values of 36 bins with ten neighbors per bin worked well in all and usages of the implementation.
			When a bin is full and a new edge should be inserted, an existing edge might be removed from the bin.
			The criterion on which edge to remove is its length such that only the $k_n$ shortest edges per angle area of the bin remain.
			Since shortest paths are wanted, storing the $k_n$ longest edges would result paths that are too long.
			
			Without this subdivision into bins and by only considering a static maximum number of neighbors, i.e. with $k$ being a single value, it is possible to only have edges to complex and close objects but no edges to obstacles further away.
			In other words, the edges would not be distributed evenly around a vertex.
			
			An example for this would be a building next to a large and open park.
			The $n$ nearest neighbors of the house are probably quite close, for example vertices of other houses, hedges or fences.
			This means that the far away other side of the park is not withing the set of neighbors, even though the other side of the park is clearly visible.
			Subdividing the neighbors into bins ensures that there will definitely be connections to the other side of the park.
			
			Generally restricting the number of neighbors and therefore reducing the number of edges leads to less accurate routing results, i.e. to suboptimal paths, which are not shortest.
			As mentioned above, one bin only contains the $k_n$ shortest edges to its neighbors.
			The significance of the negative impact due to this restriction, however, is debatable.
			In the case of using the above mentioned default values of ten edges per 10° range, an omitted edge led to a similar direction as at least nine other edges did.
			The negative influence of a detour to the total route length by using the next best edge towards the destination is most likely not significant.
			\todo{Check this in evaluation! Test: ca. 17\% of edges are removed with $(36,10)$ compared to $(3600,1000)$ with only 13\% longer calculation time}
			
		\subsubsection{Convex hull}
		\label{subsubsec:convex-hull}
			
			As mentioned in \hyperref[subsec:step-1-preprocessing]{step 1}, only visibility neighbors for vertices lying on the convex hull of any obstacle are determined.
			The visibility neighbors themselves also have to be on any convex hull, which means vertices not being on any convex hull will never be connected to other vertices.
			This filtering strategy is a simple performance enhancement with some implications on the route quality as discussed below.
			
			The reason for this filtering is quite simple:
			Vertices not being on a convex hull will never be part of a shortest path.
			This is the case, since the convex hull itself is by definition the smallest set of points that creates an areas, which in turn contains all other points of the geometry\cite[2]{de-berg-computational-geometry}.
			Interpreting the convex hull as one possible path around a shape, the triangle inequality implies that this path is in deed the shortest path around the shape.
			When determining shortest paths, the part of a route bending around an obstacle will therefore always be a subset of its convex hull.
			
			Of course, a routing query might start within a concave part of the obstacle or somewhere completely else.
			This case, however, is independent of the graph generation and belongs to answering routing queries, which is covered later in \Cref{sec:answering-queries}.
			
			Also, the weighting function for the routing queries might not determine shortest, but for example fastest routes.
			In such case, the above filtering might result in inaccurate and suboptimal paths.
			Since this is just a performance enhancement and therefore an optional step, deactivating this filtering increases preprocessing time but solves this inaccuracy problem.
						
		\subsubsection{Valid angle areas}
			
			As mentioned above, a subsection of a shortest path bending around an obstacle always follows a part of the obstacle's convex hull.
			Eventually the path switches from following the convex hull to following a visibility edge, which leads to another obstacle and therefore another convex hull part.
			
			This means, a shortest path consists of many convex hull parts that are either connected by straight lines or touching each other.
			Connecting lines, i.e. line segments connecting two convex hull parts, are the shortest connections between the two convex hull parts on that shortest path.
			In other word, they cannot be relaxed to an alternative edge, which is shorter.
			
			Assuming a shortest path, which contains a convex hull edge $e_h=(u, v)$ followed by a connecting line edge $e_c=(v, w)$, then there is no relaxation possible to an edge $e_r=(u, w)$.
			According to the triangle inequality, such edge $e_r$ would be shorter than the two others, which means $d(e_r) < d(e_h) + d(e_c)$ would hold true.
			But since $e_h$ and $e_c$ are on the shortest path, no such $e_r$ can exist because then the shortest path would not have been shortest.
			This scenario is illustrated in \Cref{fig:convex-hull} with the convex hull segment $(v_0, v_1)$, the connecting line $(v_1, v_2)$ and the impossible relaxation $(v_0, v_2)$.
			
			In fact, edges, which can be relaxed as described, will \emph{never} be part of \emph{any} shortest path.
			If such an edge would be part of an shortest path, then the path is not shortest and would rather contain the relaxed edge.
			Determining these relaxable and therefore irrelevant edges is the key motivation of angular ranges, called \term[valid angle area]{valid angle areas}.
			Only visible vertices within any valid angle area are possible subsequent vertices in shortest paths.
			
			% TODO Numbering is weird
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\coordinate (c00) at (0,0.4);
						\draw (c00)
							-- ++(2.75,-0.2) coordinate (c01)
							-- ++(0.8,0.4) coordinate (c02)
							-- ++(0.1,0.8) coordinate (c03)
							-- ++(-2,0) coordinate (c04)
							-- ++(-1.4,-0.35) coordinate (c05)
							-- (c00);
						\node[above right = 0.15 and 1.6 of c00] {$o_1$};
						
						\coordinate (c10) at (2.5,3.85);
						\draw (c10)
							-- ++(-0.4,-0.4) coordinate (c11)
							-- ++(0.1,-0.6) coordinate (c12)
							-- ++(2.8,0) coordinate (c13)
							-- ++(-0.4,1.2) coordinate (c14)
							-- (c10);
						\node[below right = 0.25 and 0.75 of c10] {$o_2$};
						
						\def\d{1.5\pgflinewidth}
						\filldraw[thin,Green4!35!white] ($(c03)+(0,\d)$) -- +(180:0.35) arc [start angle=180, delta angle=-97.126, radius=0.35];
						\draw[thin,Green4] (c03) -- (intersection of c03--[shift=(c03)]82.874:3 and c12--c13);
						\draw[thin,Green4] ($(c03)+(0,\d)$) -- +(180:4);
						%							
						\filldraw[thin,DodgerBlue3!35!white] ($(c12)+(0,-\d)$) -- +(279.462:0.4) arc [start angle=279.462, delta angle=80.538, radius=0.4];
						\draw[thin,DodgerBlue3] (c12) -- (intersection of c12--[shift=(c12)]279.462:1 and c03--c04);
						\draw[thin,DodgerBlue3] ($(c12)+(0,-\d)$) -- +(0:4);
						
						\tikzDot[label={right:$s$}]{(c01)}{s}
						\tikzDot[label={right:$v_0$}]{(c02)}{v0}
						\tikzDot[label={right:$v_1$}]{(c03)}{v1}
						\tikzDot[label={left:$v_2$}]{(c12)}{v2}
						\tikzDot[label={below:$v_3$}]{(c13)}{v3}
						\tikzDot[label={above:$v_4$}]{(c04)}{v4}
						\tikzDot[label={left:$t$}]{(c10)}{t}
						
						\draw[->,Red2,thick] (s) -- (v0);
						\draw[->,Red2,thick] (v0) -- (v1);
						\draw[->,Red2,thick] (v1) -- (v2);
						\draw[->,Red2,thick] (v2) -- (c11);
						\draw[->,Red2,thick] (c11) -- (t);
					\end{tikzpicture}
				\end{figcenter}
				\caption{
					The path from $s$ via $v_1$ and $v_2$ to $t$ bends along the convex hulls of $o_1$ and $o_2$.
					The segment from $v_1$ to $v_2$ is a connecting line between the hull parts.
					% Suppose $v_2$ would be part of $o_1$, then the path from $s$ via $v_1$ to $v_2$ would be on its convex hull. Same holds true for $v_1$ and $o_2$ respectively.
					\\
					The angle area at $v_1$ marked in green indicates one of its valid angle areas.
					A visibility neighbors within this angle area can appear as a successor to $v_1$ in a shortest path.
					\\
					Vertex $v_3$, however, will never be a successor of $v_1$ on any shortest path.
				}
				\label{fig:convex-hull}
			\end{figure}
			
			These valid angle areas of a vertex $v$ are determined by its obstacle neighbors.
			For each pair of adjacent obstacle neighbors being at least $180^\circ$ apart from each other, two valid angle areas exist and are calculated as shown in the following example.
			Consider \Cref{fig:convex-hull} with the vertex $v_1$ and both obstacle neighbors $v_0$ and $v_4$.
			The area marked in green represents one of $v_1$'s valid angle areas determined by the two bearings $b(v_1, v_0)$ and $b(v_1, v_4)$ resulting in the angle interval $[b(v_1, v_4), b(v_1, v_0) - 180^\circ] = [270^\circ, 187.125^\circ - 180^\circ] = [270^\circ, 7.125^\circ]$.
			Subtracting $180^\circ$ of both bearings yields the second valid angle area of $[b(v_1, v_4) - 180^\circ, b(v_1, v_0)] = [90^\circ, 187.125^\circ]$.
			
			If one or no obstacle neighbor exists, then there is only one valid angle area covering $360^\circ$.
			No valid angle areas exist for obstacle neighbors being less than $180^\circ$ apart.
			A maximum of four valid abgle areas exist for the central vertex of three collinear vertices, in other words for one vertex with to obstacle neighbors being exactly $180^\circ$ apart.
			The valid angle areas in such case have a range of $0^\circ$ but are still used in the implementation to create edges for collinear neighbors.
			
			Since this is solely a performance optimization, the same considerations apply as in the above shown convex hull filtering.
			As soon as the weighting function is not creating a shortest path, this optimization might lead to suboptimal paths.
			Again, removing this optimization solves this problem.
			
		\subsubsection{Intersection checks}
		\label{subsubsec:intersection-checks}
			
			There are two types of intersection checks needed.
			One for line segment intersections and one to check whether or not a point lies within a triangle.
			Both intersection checks are performed using an own implementation instead of methods from the the NetTopologySuite.
			This has solely performance reasons since this specially tailored implementations are faster than the NTS methods.
			
			Performing ten million collision checks on random line segments with the custom implementation takes 195 ms on average, the fastes NTS method was \texttt{IntersectionComputer.Intersection()} and took 371 ms.
			Other method like the \texttt{RobustLineIntersector} (746 ms) or \texttt{LineSegment.Intersection} (1552 ms) were slower.
			
			Analoguously, performing one million random triangle intersection checks required 138 ms on average using the custom implementation and 174 ms using the fastest NTS method \texttt{Triangle.Intersects()}.
			Other method like \texttt{IPreparedGeometry.Intersects()} (406 ms), the \texttt{IndexedPointInAreaLocator} (707 ms) or the simple \texttt{Polygon.Intersects()} (2424 ms) were slower.
			
			The line segment intersection check uses an approach based on cross products as presented in \emph{Introduction to algorithms} by Thomas H Cormen et al.\cite[1018]{cormen-introduction-to-alg}.
			Due to the performance of this approach, it is used to check whether a line segment intersects with a whole obstacle by performing this intersection check for each segment of the obstacle.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\tikzDot[label={below left:$(1,0,0)$}]{(0,0)}{a}
						\tikzDot[label={below right:$(0,1,0)$}]{(4,0)}{b}
						\tikzDot[label={above:$(0,0,1)$}]{(2,3)}{c}
						
						\coordinate[between={a and c}] (ac);
						\coordinate[between={b and c}] (bc);
						\coordinate[between={a and b}] (ab);
						
						\draw (a) -- (b);
						\draw (a) -- (c);
						\draw (b) -- (c);
						
						\draw[dotted] (a) -- (bc);
						\draw[dotted] (b) -- (ac);
						\draw[dotted] (c) -- (ab);
						
						\tikzDot{(intersection of a--bc and b--ac)}{center};
						\node[below=1mm of center,inner sep=0mm,fill=white] {$c=(\nicefrac{1}{3},\nicefrac{1}{3},\nicefrac{1}{3})$};
						
						\tikzDot[label={left:$a=(0.5,0,0.5)$}]{(ac)}{left}
						\tikzDot[label={right:$b=(-0.2,0.5,0.7)$}]{(3.4,2.1)}{right}
					\end{tikzpicture}
				\end{figcenter}
				\caption{A triangle with barycentric coordinates and dotted lines for the three coordinate axes. Noteworthy is coordinate $b$ as it is outside the triangle, which can be directly seen from the negative value $-0.2$.}
				\label{fig:barycentric-triangle}
			\end{figure}
			
			Checking if a vertex lies inside a triangle is used for closed obstacles, which got triangulated during \hyperref[subsec:step-1-preprocessing]{preprocessing}.
			This method creates a barycentric coordinate system in which each coordinate has the form $(\lambda_1,\lambda_2,\lambda_3)$.
			For each corner of the triangle, exactly one value of the coordinate is one and the other two values are zero.
			\Cref{fig:barycentric-triangle} illustrates this with some exemplary points.
			Due to the properties of this coordinate system, a point $p$ is inside the triangle when the condition $0 < \lambda_i < 1$ is satisfied for all three values.
			
			Even though it sounds complex to create a whole coordinate system for a single collision check, this method only requires a few lines of code, uses only multiplications, additions and boolean operations and is therefore very fast.
			
		\subsubsection{Shadow area operations}
			
			The shadow areas are stored in the previously described \hyperref[subsec:binindex]{BinIndex} data structure.
			Inserting of the intervals therefore works as described in \Cref{subsec:binindex}.
			
			Shadow areas are always determined for a single vertex $v$.
			Checking if a different vertex $u$ is within any shadow area, and therefore not visible from $v$, is quite simple.
			First, all shadow areas are queried that fall into the bin of the $u$'s angle.
			Second, for each shadow area $s$ it is checked whether $u$ is at least a far away from $v$ as the minimum distance of $s$ and whether the vertex is exactly within the angle area of $s$.
			If both holds true for any such shadow area $s$, then $u$ is not visible from $v$.
		
		\subsubsection{Visibility graph generation overview}
		
			The performed steps of determining the visibility neighbors are the following.
			Each step is described with more details in the sections below.
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.},label={2.\arabic*.}]
				\item Determine the obstacle neighbors for each vertex.
				\item For each vertex $v$ lying on any convex hull, determine its visibility neighbors.
%				\begin{enumerate}
%					\item For each other vertex $u$, do the following:
%					\begin{enumerate}
%						\item Is $u$ in any shadow area \emph{or} not on any convex hull \emph{or} not in any valid angle area? If so: $u$ is not relevant, move to the next other vertex.
%						\item Query all obstacles between $v$ and $u$. This is done by the bounding box spanned by $v$ and $u$.
%						\item Create and store the shadow area of each such obstacle $o$.
%						\item Check if $u$ is a visibility neighbor, which is true if $u$ is a) still not in any shadow area and b) the line segment from $v$ to $u$ intersects with none of the above queries obstacles.
%					\end{enumerate}
%				\end{enumerate}
				\item Sort the visibility neighbors into bins based on the obstacle neighbors.
			\end{enumerate}
		
		\subsubsection{Step 2.1: Determining obstacle neighbors}
			
			Obstacle neighbors are needed to correctly handle the closed surface of obstacles, especially when two obstacles tough each other.
			This handling of neighbors is then used to form the valid angle areas, which in turn are used to determine whether a distant vertex is relevant for visibility checks.
			
			Determining the obstacle neighbors is relatively simple and straight forward.
			Each vertex $v$ of an obstacle $o$ is processed by looking at the previous and next vertices $v_p$ and $v_n$ on the same obstacle, which are both potential obstacle neighbors.
			If the line segment $(v, v_p)$, same applies to $v_n$, does not intersect with any other obstacle and is not an edge on any other obstacle, it is considered an obstacle neighbor.
			Latter case can be seen in \Cref{fig:obstacle-neighbors-touching} at the line segment $(v_1, v_3)$, which is part of two touching obstacles.
						
			\begin{figure}[h]
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot[label={[text=gray]below:$v_0$},gray]{(0,0)}{v0}
							\tikzDot[label=above:$v_1$]{(1,1.5)}{v1}
							\tikzDot[label=below:$v_2$]{(2,0)}{v2}
							\tikzDot[label=above:$v_3$]{(3,1.5)}{v3}
							\tikzDot[label={[text=gray]below:$v_4$},gray]{(4,0)}{v4}
							
							\draw[gray] (v0) -- (v1);
							\draw[->,very thick] (v2) -- (v1);
							\draw[->,very thick] (v2) -- (v3);
							\draw[gray] (v3) -- (v4);
						\end{tikzpicture}
					\end{figcenter}
					\caption{The black lines show the obstacle neighbors of $v_2$, which are $v_1$ and $v_3$.}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\def\d{1.5}
							
							\tikzDot[gray]{(0,0)}{c00}
							\tikzDot[label=above:$v_0$]{(0,\d)}{v0}
							\tikzDot[label=above:$v_1$]{(\d,\d)}{v1}
							\tikzDot[label=above:$v_2$]{(2*\d,\d)}{v2}
							\tikzDot[label={[text=gray]below:$v_3$},gray]{(\d,0)}{v3}
							\tikzDot[gray]{(2*\d,0)}{c20}
							
							\node at (0.5*\d,0.5*\d) {$o_1$};
							\node at (1.5*\d,0.5*\d) {$o_2$};
							
							\draw[gray] (c00) -- (v0);
							\draw[gray] (c00) -- (v3);
							\draw[->,very thick] (v1) -- (v0);
							\draw[->,very thick] (v1) -- (v2);
							\draw[->,gray] (v1) -- (v3);
							\draw[gray] (c20) -- (v3);
							\draw[gray] (c20) -- (v2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{The black lines show the obstacle neighbors of $v_1$, which are $v_0$ and $v_2$. The vertex $v_3$ is a neighbor as well, but hidden due to the touching obstacles $o_1$ and $o_2$ and therefore not an obstacle neighbor.}
					\label{fig:obstacle-neighbors-touching}
				\end{minipage}
			\end{figure}
			
			Because the step of determining the obstacle neighbors is very important for finding all relevant visibility neighbors, the implementation is within the \texttt{VisibilityGraphGenerator} class, namely the \texttt{AddObstacleNeighborsForObstacles} method.
			Each of the following steps is within this class as well, due to the close relationship.
			
		\subsubsection{Step 2.2: Determining visibility neighbors}
		
			As mentioned above, the \texttt{VisibilityGraphGenerator} class also contains the necessary methods to determine the visibility neighbors for every vertex.
			Essential to this process is the \texttt{GetVisibilityNeighborsForVertex} method determining the visibility neighbors for a single vertex.
			This method uses the concept of shadow areas stored in a BinIndex structure with a bin count of 360, each bin covering a 1° area.
%				Additionally, all obstacles casting a shadow are separately stored, simply to check whether or not a obstacle already casts a shadow.
%				Since querying of obstacles is necessary, they are stored in a QuadTree.
			
			The following steps are performed for every vertex $v$ being part of any convex hull.
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.},label={2.2.\arabic*.}]
				\item Continue with the next vertex if any of these conditions is true (otherwise process with the next step): Vertex $u$ is in a shadow area \emph{or} $u$ is outside a valid angle area \emph{or} $u$ is not part of any convex hull.
				\item Query all obstacles in the extent spanned by $v$ and $u$. For each obstacle $o$ the following steps are performed:
				\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.}-1em]
					\item Get or create the shadow area for $o$.
					\item If a new shadow area $S$ was just created \emph{and} $u \in S$, \emph{then} mark $u$ as hidden and skip all subsequent obstacles and continue with the next vertex.\label{itm:if-u-not-on-obstacle}
					\item At this point $u \not\in S$, so if $u$ is within the angular range of the obstacle as seen from $v$ \emph{and} there is an intersection of $o$ with the line segment $(v, u)$ (using the methods described above in \emph{\nameref{subsubsec:intersection-checks}}), \emph{then} mark $u$ as hidden.
				\end{enumerate}
				\item If $u$ has been marked as hidden, continue with the next vertex.
				\item If $u$ is visible, store it in the according bin for its angle and continue with the next vertex
			\end{enumerate}
			Having all visibility neighbors according to the amount and size of the bins, they are sorted in new bins based on the obstacle neighbors.
			This procedure is described in the following section and its result is stored for the graph creation, which is described below in \Cref{subsec:step-3-graph-creation}.
		
		\subsubsection{Step 2.3: Sort resulting visibility neighbors into bins}
		
			A naive approach to create a visibility graph would be to create edges between vertices that are visible to each other.
			This would make routing through line-based obstacles possible as \Cref{fig:routing-through-line-obstacle} illustrates.
			Such routing behavior is, of course, not desired.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\tikzDot{(2,0)}{vo0};
								\tikzDot[label={[label distance=-1.25mm]above right:$v $}]{(2,1)}{vo1};
								\tikzDot{(2,2)}{vo2};
								
								\draw (vo0) -- (vo1);
								\draw (vo1) -- (vo2);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo1);
								\draw[dotted] (vo1) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption{
							Visibility graph with naive connections.
							The two visibility edges at $v$ allow the shortest path to go through the obstacle from $n_a$ via $v$ to $n_b$.
						}
						\label{fig:routing-through-line-obstacle-a}
					\end{subfigure}
					\hfill
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\def\r{0.85mm}
								\def\rMargin{1.1mm} % = r + 0.25mm
								\def\gap{0.1875mm}
								
								\tikzDot{(2,0)}{vo0};
								\node (vo1) at (2,1) {};
								\node[label={[label distance=-1.25mm]above left:$v_a$}] at (vo1) {};
								\node[label={[label distance=-1.25mm]above right:$v_b$}] at (vo1) {};
								\coordinate (vo11) at ($(vo1)+(180:\rMargin)$);
								\coordinate (vo12) at ($(vo1)+(0:\rMargin)$);
								\tikzDot{(2,2)}{vo2};
								
								\filldraw (vo1)++(-\gap,0)++(90:\r) arc (90:270:\r);
								\filldraw (vo1)++( \gap,0)++(90:\r) arc (90:-90:\r);
								
%								\draw (vo1)++(270:\rMargin) -- (vo0);
								\draw ($(vo1)+(270:\r)+(-0.275mm,0)$) -- ($(vo0)+(-0.275mm,2mm)$) -- (vo0.north);
								\draw ($(vo1)+(270:\r)+( 0.275mm,0)$) -- ($(vo0)+( 0.275mm,2mm)$) -- (vo0.north);
%								\draw (vo1)++(90:\rMargin) -- (vo2);
								\draw ($(vo1)+(90:\r)+(-0.275mm,0)$) -- ($(vo2)+(-0.275mm,-2mm)$) -- (vo2.south);
								\draw ($(vo1)+(90:\r)+( 0.275mm,0)$) -- ($(vo2)+( 0.275mm,-2mm)$) -- (vo2.south);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo11);
								\draw[dotted] (vo12) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption{
							The visibility graph with connection respecting the obstacle. Vertex $v$ is split into two, $v_a$ and $v_b$, with exact same location. All gaps are for illustration purposes only.
							Vertex $v_a$ is connected to $n_a$ and $v_b$ to $n_b$ but $v_a$ and $v_b$ are not connected.
							This ensures that the shortest path from $n_a$ to $n_b$ does not lead through the middle vertex of the obstacle anymore.
						}
						\label{fig:routing-through-line-obstacle-b}
					\end{subfigure}
				\end{figcenter}
				\caption{
					Both illustrations show two of $v$'s visibility neighbors $n_a$ and $n_b$ next to a vertical obstacle. Routing through this obstacle should \emph{not} be possible.
					The dotted edges are visibility edges, the solid edges normal line segments of the obstacle.
				}
				\label{fig:routing-through-line-obstacle}
			\end{figure}
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\def\d{0.03}
						
						\tikzDot[label=below:$v$]{(0,0)}{v}
						
						\tikzDot[label=left:$n_1$]{(-2.25,0)}{n1}
						\tikzDot[label=above:$n_2$]{(0,2)}{n2}
						\tikzDot[label=right:$n_3$]{(2.25,0)}{n3}
						
						\draw[lightgray] (v) -- (n1);
						\draw[lightgray] (v) -- (n3);
						\draw[lightgray] (v) -- (n2);
						
						% Visibility edges to n1
						\tikzDot[DodgerBlue3]{(-1.1,-0.25)}{vn1}
						\tikzDot[DodgerBlue3]{(-1.6,-0.9)}{vn2}
						\tikzDot[DodgerBlue3]{(1.6,-0.5)}{vn3}
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn1);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn2);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn3);
%							\draw[DodgerBlue3,densely dashed,->] ($(v)+(-0.075,-\d)$) -- ($(n1)+(0.075,-\d)$);
%							\draw[DodgerBlue3,densely dashed,->] ($(v)+(0.075,-\d)$) -- ($(n3)+(-0.075,-\d)$);
						
						% Visibility edges to n3
						\tikzDot[Red2]{(0.7,1.4)}{vn4}
						\tikzDot[Red2]{(2,1)}{vn5}
						\draw[Red2,densely dotted,->] (v) -- (vn4);
						\draw[Red2,densely dotted,->] (v) -- (vn5);
%							\draw[Red2,densely dotted,->] ($(v)+(0.075,\d)$) -- ($(n3)+(-0.075,\d)$);
%							\draw[Red2,densely dotted,->] ($(v)+(\d,0.075)$) -- ($(n2)+(\d,-0.075)$);
						
						% Visibility edges to n2
						\tikzDot[Green4]{(-2,1.3)}{vn6}
						\draw[Green4,dashdotted,->] (v) -- (vn6);
%							\draw[Green4,dashdotted,->] ($(v)+(-\d,0.075)$) -- ($(n2)+(-\d,-0.075)$);
%							\draw[Green4,dashdotted,->] ($(v)+(-0.075,\d)$) -- ($(n1)+(0.075,\d)$);
					\end{tikzpicture}
				\end{figcenter}
				\caption{All visible neighbors of $v$ colored by their resulting bin. The neighbors $n_1$, $n_2$ and $n_3$ are also sorted into bins but they occur in each adjacent bin. The means $n_2$ is in the bin for area $n_1$/$n_2$ as well as in the bin for $n_2$/$n_3$.}
				\label{fig:visibility-bin-sorting}
			\end{figure}
			
			To correctly split and connect vertices, as illustrated for vertex $v$ in \Cref{fig:routing-through-line-obstacle}, it must be known which visibility neighbors are within the angular range of which adjacent obstacle neighbors.
			Knowing this enables the graph generation to sort all visibility neighbors into bins, as shown in \Cref{fig:visibility-bin-sorting}.
			Each of the resulting bins of a vertex $v$ covers the area between two adjacent obstacle neighbors.
			Later, in \hyperref[subsec:step-3-graph-creation]{step 3}, each bin leads to one new vertex.
			In the mentioned illustration, there would be two bins, one containing $n_a$ and one containing $n_b$, leading to two new vertices $v_a$ and $v_b$.
			
	\subsection{Step 3: Visibility graph creation}
	\label{subsec:step-3-graph-creation}
	
		The previous step created the raw data that is needed to generate a routable visibility graph, which is done in this third step.
		Since the \texttt{SpatialGraph} class in the NetTopologySuite uses the term \emph{node}, the term \emph{vertex} in this section refers to the vertices in the result of step 2, the term \emph{node} refers to the nodes in the output graph.
		
		As described at the end of the previous step, one node is created for each bin of neighboring vertices.
		Therefore, mappings between nodes, vertices and neighbor bins have to be created.
		For an example, consider \Cref{fig:routing-through-line-obstacle-b} where neighbor vertex $n_a$ should be connected to $v$.
		Since $v$ is split into two vertices, two nodes are created in the graph and therefore a mapping from node to bin is needed in order to connect the right nodes with each other.
		Two iterations over all vertices are used to first create the nodes with the respective bin-mapping and then, in the second iteration, this mapping is used to correctly connect all nodes.
		
		Without this mapping, it would not be clear to what node to connect.
		As the example in \Cref{fig:routing-through-line-obstacle} shows, without a mapping between visibility neighbor bins and nodes, it is unclear whether to connect $n_a$ to $v_a$ or to $v_b$ because they both are on the exact same location.
		
		The resulting spatial graph together with some of the mappings, which will be used to \hyperref[sec:answering-queries]{answer routing queries}, are stored in an instance of the \texttt{HybridVisibilityGraph} class.
		It contains the final spatial graph, as an instance of the \texttt{SpatialGraph} class provided by the MARS framework, along with all information needed to correctly add and connect new nodes.
		Adding nodes is only used for the start and destination locations of a routing query.
		
	\subsection{Step 4: Merging a road network into the visibility graph}
	\label{subsec:step-4-graph merging}
	
		To allow a routing algorithm to switch between the road network and visibility edges, the road network needs to be merged into the visibility graph.
		This happens not just by adding the road segments to the graph but by introducing and connecting new nodes at all intersections between road and visibility edges.
		\Cref{fig:merging-edges} illustrates this process for one road segment and two visibility edges.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\draw[<->,dashed] (v1n1) -- node[above right=0cm and 0.4cm] {$v$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above right=0cm and 0.4cm] {$u$} (v2n2);
							
							\draw[<->] (rn1) -- node[left] {$r$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{
						Before merging $r$ into the graph with a total of six nodes and six edges.
					}
					\label{fig:merging-edges-a}
				\end{subfigure}
				\hfill
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\tikzDot{(intersection of v1n1--v1n2 and rn1--rn2)}{i1}
							\tikzDot{(intersection of v2n1--v2n2 and rn1--rn2)}{i2}
							
							\draw[<->,dashed] (v1n1) -- node[above] {$v_1$} (i1);
							\draw[<->,dashed] (i1)   -- node[above] {$v_2$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above] {$u_1$} (i2);
							\draw[<->,dashed] (i2)   -- node[above] {$u_2$} (v2n2);
							
							\draw[<->] (rn1) -- node[right] {$r_1$} (i1);
							\draw[<->] (i1)  -- node[right] {$r_2$} (i2);
							\draw[<->] (i2)  -- node[right] {$r_3$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{
						After merging $r$. Two new vertices have been created and all edges are split on the intersection points. The graph size therefore increased by two nodes and eight edges (since all edges are bidirectional) to eight nodes and 14 edges.
					}
					\label{fig:merging-edges-b}
				\end{subfigure}
			\end{figcenter}
			\caption{
				Merging the road edge $r$ with two bidirectional visibility edges $v$ and $u$.
			}
			\label{fig:merging-edges}
		\end{figure}
	
		This final graph allows any routing algorithm to switch between road and visibility edges without further instructions or adjustments to the routing algorithm.
		

		With $E_R$ containing all road and $E_V$ all visibility edges, the complexity of the merge operation is within $\bigo{|E_R| \cdot |E_V|}$.
		This complexity arises from the fact that a road segment intersecting with $n$ visibility edges leads to $n+1$ new road segments, $n$ new intersection points and $n$ new visibility edges connecting them.
		In the worst case of a road segment intersecting with all visibility edges, $2 \cdot |E_V| + 1$ edges and $|E_V|$ nodes are added to the graph.
		Therefore, up to $|E_R| \cdot (2 \cdot |E_V| + 1)$ new edges and $|E_R| \cdot |E_V|$ new nodes are created.
		Even though it does not scale worse than linear in the input size $|E_R|$ of the road edges, the size of the output graph is significantly higher than the input road network, which are typically quite sparse networks.

		Measured graph sizes and effects on the routing performance are presented and discussed in \Cref{chap:evaluation}.
	
\section{Answering shortest path queries}
\label{sec:answering-queries}

	The process of answering shortest path queries, or routing queries in general, is directly implemented in the \texttt{HybridVisibilityGraph} class.
	Arbitrary weighting functions can be passed to customize the routing behavior.
	Implementing the core idea of determining routes between arbitrary location is, with the help of the above described techniques, rather simple:
	\begin{enumerate}
		\item \label{itm:answering-queries-add-nodes} Add nodes for the source and destination locations of the routing query to the graph.
		\item \label{itm:answering-queries-vis-edges} Determine visibility edges of each of the two nodes and merge these new edges into the graph.
		\item \label{itm:answering-queries-routing} Use a normal shortest path algorithm, such as A*, to find the path from the source to the destination.
		\item \label{itm:answering-queries-cleanup} Remove all previously added nodes and edges to get a clean graph for future routing requests.
	\end{enumerate}
	Step \ref{itm:answering-queries-add-nodes} creates two new nodes in the spatial graph as far as no node already exists at the respective location.
	
	Because step \ref{itm:answering-queries-vis-edges} is already implemented for the general graph generation, the core method \texttt{VisibilityGraphGenerator.GetVisibilityNeighborsForVertex()} can be reused without further adjustments.
	The most complex part is to determine the correct node to connect to.
	Thanks to the mappings of neighbor bins and their covered angle areas, as introduced in \Cref{subsec:step-3-graph-creation}, the correct bin for a location can be determined and a bidirectional edge be created.
	These are mostly simple filtering operations on the bins and can be implemented with very little code.
	
	Fortunately, the \texttt{SpatialGraph.RemoveNode(int)} method removes the node given by its ID and also removes all edges, which are connected to the given node.
	This makes step \ref{itm:answering-queries-cleanup} very easy since step \ref{itm:answering-queries-add-nodes} and \ref{itm:answering-queries-vis-edges} yield the IDs of created nodes, which are needed for the cleanup.
	
	\todo{Summary/wrap up/transition to evaluation chapter}
