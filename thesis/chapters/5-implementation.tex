% !TEX root = ../thesis.tex
% !TeX spellcheck = en_US

This section covers details on the implementation of the previously described design.
First, an overview of the algorithm is given including a short description of used frameworks and technologies.
Second, two new and important data structures are described in detail.
Finally, each algorithmic step of the graph generation but also of the query answering is described in the main sections of this chapter.

\section{Algorithm overview}

	In this section, details on the code dependencies are given as well as a broad overview of the algorithm.

	\subsection{Frameworks and technology}
	\label{subsec:frameworks-technology}
	
		As mentioned in \cref{subsec:constraints} about the constraints, the used programming language is C\# due to the dependency to the MARS framework.
		The MARS framework is based on the widely used C\# library \term{NetTopologySuite} (\term*{NTS}), which contains numerous data structures, algorithms and helper function to handle and process geospatial data.
		
		Primarily, the NTS was used for basic data structures like coordinates, geometries and features but also for simple operations, e.g. the calculation of distances.
		Writing data to files is also done with the help of the NTS, namely to serialize the geospatial data into the GeoJSON format.
		
		The \term*{MARS} framework was also used for basic data structures, for example the \texttt{Position} class.
		However, higher level structures were used as well, such as \texttt{SpatialGraph} or \texttt{QuadTree} classes.
		
		Not all data structures and algorithms already existed to create the hybrid routing graph.
		Most notably, a \hyperref[subsubsec:intersection-checks]{fast line intersection check}, a \hyperref[subsec:binindex]{bin-based index} and a fast \hyperref[subsec:shadow-areas]{vertex filtering method} were implemented.
		The latter one refers to the so called \emph{shadow areas} in the sections below.
		Several other helper functions and simpler structures, for instance separate classes for vertices and obstacles, were added as well.
	
%	\subsection{Chosen approach and potentially faster known algorithms}
%
%		Due to the step by step development by turning the former continuous dijkstra preprocessing into a visibility graph generator, the implemented approach does not follow algorithms described in the literature.
%		The performance of this implementation, as shown in \todo[inline]{link to evaluation chapter}, is still enough for practical use, but a well designed and fast algorithm, like the one presented by Overmars and Welzl \cite{overmars-weizl-visibility-graph} or the one by Ghosh and Mount \cite{ghosh-output-sensitive-vgraph}, would clearly increase performance.
%		However, this performance enhancement would only affect the generation of a visibility graph and not the performance of the routing queries.
			
	\subsection{Algorithm steps}
	\label{subsec:algorithm-steps}
	
		In the following, the main steps of the two parts of this algorithm are outlined:
		The graph generation and the answering of routing requests.
		
		\subsubsection{Graph generation}
		\label{subsubsec:graph-generation}
		
			The \texttt{HybridVisibilityGraphGenerator} class provides a factory method to create an instance of the \texttt{HybridVisibilityGraph} class from a given collection of features.
			This factory method consists of the following top level steps, which are all described in \cref{sec:visibility-graph-creation} in more detail:
			\begin{enumerate}
				\item \hyperref[subsec:step-1-preprocessing]{Filter the given features for obstacles}
				\item \hyperref[subsec:step-2-knn-search]{Determine the visibility neighbors}
				\item \hyperref[subsec:step-3-graph-creation]{Use this visibility relation to create a visibility graph}
				\item \hyperref[subsec:step-4-graph merging]{Merge the existing road network into this graph}
			\end{enumerate}
			The resulting hybrid visibility graph then allows to route between existing nodes.
			So far, routing queries between arbitrary locations cannot be answered, only between existing nodes.
			Handling arbitrary location is part of the next step.
		
		\subsubsection{Answering routing queries}
		
			To enable answering routing requests between arbitrary locations the resulting graph needs to be extended with edges from and to the given start and end locations.
			These edges themselves are visibility edges and can therefore be created and merged just like the visibility edges before.
			Further details are given in \cref{sec:answering-queries} describing the following steps:
			\begin{enumerate}
				\item Determine visibility edges for source and destination coordinates\label{itm:step-merging-source-dest}
				\item Merge these edges into the graph such that they can be removed afterwards
				\item Route along the resulting graph (e.g. by using the A* algorithm)
				\item Restore the original graph by removing all nodes and edges added in step \ref{itm:step-merging-source-dest}
			\end{enumerate}
			The last step ensures that subsequent routing queries are answered based on the original graph and not on an altered version of it.
			It also prevents an uncontrolled growth of the graph.
	
\section{Data structures}
	
	Before the separate steps of the graph generation are described in detail, the newly created data structures are presented.
		
	\subsection{Shadow areas}
	\label{subsec:shadow-areas}
		
		Shadow areas are a method I designed and implemented to quickly determine and filter out vertices that are not visible to each other.
		The motivation and the idea behind shadow areas is the following:
		Having a light bulb as a single light source, everything within a shadow is not visible from that light bulb.
		Interpreting a vertex $v$ as a light bulb illuminating its surroundings, an obstacle $o$ casts a shadow outwards and every vertex within this shadow is definitely not visible from $v$.
		
		Each shadow is determined by three values: two values for the angular range (also referred to as \emph{angle area}) and a third value for the minimum distance from which other vertices within the angular range are definitely not visible.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\angle{20}
					\def\boundingVertexDistance{3}
					
					\tikzDot[label=$v$]{(0,1.5)}{v}
					\coordinate (shadow-arc-top)				at ($(v) +( \angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-bottom)				at ($(v) +(-\angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-top-end)			at ($(v) +( \angle:5.75)$);
					\coordinate (shadow-arc-bottom-end)			at ($(v) +(-\angle:5.75)$);
					\coordinate (shadow-arc-top-faded-end)		at ($(v) +( \angle:6.5)$);
					\coordinate (shadow-arc-bottom-faded-end)	at ($(v) +(-\angle:6.5)$);
					
					% Gray area
					\filldraw[lightgray] 
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					cycle;
					\draw[gray]
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end);
					
					\draw[dotted] (v) -- (shadow-arc-top);
					\draw[dotted] (v) -- (shadow-arc-bottom);
					
					% Faded gray area
					\filldraw[draw=none,lightgray,path fading=east]
					(shadow-arc-top-faded-end) --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom-faded-end) --
					cycle;
					\draw[gray,path fading=east] (shadow-arc-top-end) -- (shadow-arc-top-faded-end);
					\draw[gray,path fading=east] (shadow-arc-bottom-end) -- (shadow-arc-bottom-faded-end);
					
					% Obstacle
					\tikzDot[red]{(shadow-arc-top)}{o0}
					\tikzDot{(3.8,2)}{o1}
					\tikzDot[red]{($(v) +(-\angle:1.2)$)}{o2}
					\node[above right = 0.5 and 1.15 of o2] {$o$};
					
					% v' and v''
					\tikzDot[label=right:$v'$]{(2.1,1.1)}{v'}
					\tikzDot[label=right:$v''$]{(3.4,1.3)}{v''}
					
					\node[darkgray] at (4.7,1.5) {\huge$S$};
					
					\draw (o0) -- (o1) -- (o2) -- (o0);
				\end{tikzpicture}
			\end{figcenter}
			\caption{Shadow area $S$ cast by obstacle $o$ seen from vertex $v$. The two red vertices of obstacle $o$ are the bounding vertices determining angular range and distance of $S$. The vertex $v''$ is not visible from $v$ since it lies inside the shadow area. Note that $v'$ is not visible either even though it is not inside the shadow area.}
			\label{fig:shadow-area}
		\end{figure}
		
		The angular range is determined by two vertices, the \emph{bounding vertices} as marked in red in \cref{fig:shadow-area}, one with the smallest and one with the largest angle from the processed vertex $v$.
		Thus, the shadow area covers the largest possible angular range for the obstacle it belongs to.
		
		Having the distances from $v$ the two bounding vertices, the larger distance is the overall distance of the shadow area.
		Choosing any other distance, e.g. the smaller distance of these two, would result in a shadow area leading to false positive visibility checks, meaning the checked vertex is within the shadow but it is actually visible from $v$.
		Taking the larger distance into account results in false negative results (as for $v'$ in \cref{fig:shadow-area}), meaning the vertex is not within a shadow but not visible, which can be handled by a full visibility check.
		Additionally when using the larger distance, positive results, meaning the checked vertex is within a shadow and seems to be not visible from $v$, are always true positive results and need no further checking.
		
		Calculating the shadow area of an obstacle is a linear time operation (linear in the amount of vertices of the obstacle) and requires just a few arithmetic operations.
		
		For example for the currently processed vertex $v$, a shadow area can range from 45° to 90° and starts at a distance of 5 meters.
		This means a vertex at 60° and 3 meters distance might be visible from $v$ but a visibility check is needed.
		A vertex at 60° and 6 meters distance is definitely not visible.
		This scenario is illustrated in \cref{fig:shadow-area} with vertices $v'$ and $v''$.
		
		In terms of data structures, each shadow is an interval (between 0 and 360) of certain distance, which turns the visibility problem into an interval intersection problem.
		Thus, checking whether a certain coordinate is within any shadow area is a simple operation using just a few arithmetic operations.
		
		Keeping track of these shadow areas for each vertex significantly improves performance, especially with the use of the \texttt{BinIndex} data structure described \hyperref[subsec:binindex]{below}.
		\todo[inline]{Evaluation why this is fast.}
		
		% NetworkRoutingPlayground->Jungfernstieg dataset with 7916 vertices: ~7.3s with and 67s without shadow areas -> speedup of factor ~9
		% Hamburg inner city dataset with 67819 vertices: 382s with and ~31000s without shadow areas -> speedup of factor ~81
		
	\subsection{BinIndex data structure}
	\label{subsec:binindex}
		
		The \texttt{BinIndex} class implements a linear bin-based index structure to store and access intervals.
		It contains $n$ many bins covering a certain range and each bin consists of a linked list.
		Items are added to each bin that intersect with the range of the item.
		Due to the linked list as the underlying data structure for the bins, point queries can be answered in constant and range queries in linear time.
		However, range queries are not needed within the scope of this work, so they are not implemented.
		\Cref{fig:bin-index} illustrates this data structure with a simple example.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\l{0.5}
					\def\countX{9} % One more is added due to start at x=0
					\def\countY{1} % One more is added due to start at x=0
					
					\def\itemBStartX{1.6}
					\def\itemBIndexStart{1}
					\def\itemBLength{4.1}
					
					\def\itemAStartX{4}
					\def\itemAIndexStart{4}
					\def\itemALength{7.8}
					
					% Item A: Bins 1-5
					\draw[dotted,gray] (\itemBStartX*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\draw[dotted,gray] (\itemBStartX*\l+\itemBLength*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\filldraw[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBStartX*\l,\countY+4*\l) rectangle node[above right=0.125 and -1.3]{Item B: \itemBStartX\ - 5.7} ++(\itemBLength*\l,0.5*\l);
					
					% Item B: Bins 4-11(2)
					\draw[dotted,gray] (\itemAStartX*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\draw[dotted,gray] (\itemAStartX*\l+\itemALength*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\filldraw[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAStartX*\l,\countY+3*\l) rectangle node[above right=0.125 and -0.5]{Item A: \itemAStartX\ - 10.8} ++(\itemALength*\l,0.5*\l);
					
					\draw[->] (\itemAStartX*\l+1.85,\countY+2.75*\l) -- node[right] {1.} +(0,-1.5*\l);
					\draw[->] (\itemBStartX*\l+0.5,\countY+3.75*\l) -- node[right] {2.} +(0,-2.5*\l);
					
					% Draw pattern to bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+1*\l,0) rectangle ++(2*\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAIndexStart*\l,0) rectangle ++(6*\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (0,0) rectangle ++(2*\l,\l);
					
					% Draw gray versions of filled bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=lightgray] (\l*\countX+\l+\itemBIndexStart*\l+1*\l,0) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=lightgray] (\l*\countX+\l,0) rectangle ++(2*\l,\l);
					
					% Draw outlines of repeating gray bins
					\foreach \x in {0,...,2}
					{
						\draw[lightgray] (\l*\countX+\l+\l*\x,0) rectangle ++(\l,\l);
						\node[lightgray] at (\l*\countX+\l+\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					% Draw outlines of bins
					\foreach \x in {0,...,\countX}
					{
						\draw (\l*\x,0) rectangle ++(\l,\l);
						\node at (\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					\draw (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+0.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+3.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+4.5*\l,\l) -- ++(0,0.5*\l);
					
					\node at (0.5*\countX*\l,-0.875) {bins};
					\node[align=right] at (-1.25,0.5*\countY*\l+0.5*\l) {Linked lists\\of bins};
				\end{tikzpicture}
			\end{figcenter}
			\caption{Bin index filled with two items A (added first) and B (added last). Since item A was added first, B's entries in, which fall into a bin where en entry for item A already exists, are moved to a next item in the linked list of the bin. Each bin covers a range, which means non integer value are rounded down (for from-values) or up (for to-values).}
			\label{fig:bin-index}
		\end{figure}
		
		The NetTopologySuite offers several indices specifically made for intervals, namely the \texttt{BinTree}, \texttt{SIRtree} and \texttt{SortedPackedIntervalRTree}, of which only the first one is dynamic and thus allows insertions and deletions after the first query was made.
		This dynamic behavior is crucial for an efficient use of the shadow areas.
		Otherwise, the shadow areas must be created in beforehand, added to and index and then be used, which results in a large number of unnecessary areas being added to the index.
		
		Even though these three data structures are tree-based and offer a logarithmic query time complexity for queries, compared to the linear time complexity of the \texttt{BinIndex}, the simple and list-based \texttt{BinIndex} is significantly faster even for larger datasets with tens of thousands of vertices.
		%It is thinkable that the logarithmic complexity is useful for even larger datasets with millions of vertices.
		\todo[inline]{Measure performance + Point when the tree is better}
		
\section{Routing graph creation}
\label{sec:visibility-graph-creation}
		
	This section presents implementation details on the steps given in \cref{subsubsec:graph-generation} for graph generation, which includes generating a visibility graph and merging it with a road network.

	\subsection{Step 1: Obstacle filtering and feature preprocessing}
	\label{subsec:step-1-preprocessing}
			
		The first step is to filter all input features by their attributes to get all relevant obstacle features, regardless of their geometry.
		
		For performance reasons, multi-geometries, like \texttt{MultiPolygon} are split up into their separate geometries.
		% TODO Add remarks on handling islands in multi-polygons (s. ticket).
		%Holes in a polygon are not reachable in the first place and unwrapping the \texttt{MultiPolygon} will not change this.
		Unwrapping \texttt{MultiLineString} geometries is unproblematic as well, since the result are just multiple normal linestrings.
		Features made of \texttt{Point} geometries are also considered so that visibility edges can reach \term*{points of interest}.
		Visibility checks, which are performed in the next step of the algorithm, can ignore point features, since they have no spatial size.
		
		Another task within this first step is the triangulation of all polygonal shapes, which happens during the unwrapping of multi geometries.
		The main reason is a better performance for intersection checks, which is an important operation when checking if an obstacle is between two vertices.
		Details on the intersection check implementation are given \hyperref[subsubsec:intersection-checks]{below}.
		
		Also worth mentioning is the determination of each obstacles' convex hull.
		Of course this is not a complex task, since all obstacles are either triangles (due to the triangulation), linestrings or points.
		As described \hyperref[subsubsec:convex-hull]{below}, only vertices on the convex hull of obstacles will be considered in the further processing, which is a simple performance enhancement.
			
	\subsection{Step 2: Determining $k$ nearest visible neighbors}
	\label{subsec:step-2-knn-search}
			
		This step performs the main task of the visibility graph creation, namely the determination of all $k$ many visible neighbors for each vertex.
%		Determining not only $k$ but all visible neighbors would also be possible, but the parameter $k$ is an easy way to increase performance with the downside of not having all possible edges in the final routing graph.
%		The fact of potential suboptimal routes is discussed in the following.
		Before the actual algorithm is presented, some concepts and optimizations are described to understand the implemented algorithm.
		Then an overview of the performed steps is given followed by details on each of these steps.
		
		\subsubsection{Terminology}
		
			Before describing the details on determining the $k$ nearest neighbors, there are some terms that need to be defined.
			
			\begin{description}
				\item[obstacle] An \term{obstacle} is a geometry that should be avoided when determining shortest paths. It can be any type of geometry, not only a polygon.
				\item[visibility neighbor] A \term{visibility neighbor} (sometimes also \emph{visible neighbor}) of a vertex $v$ is another vertex $u$, which is visible to $v$ and vice versa. In other words an imaginary linestring from $v$ to $u$ does not intersect with any obstacle.
				\item[obstacle neighbor] An \term{obstacle neighbor} of a vertex $v$ is another vertex $u$ with the property that an (undirected) edge $\{v, u\}$ exists on that obstacle. In other words, $u$ is visible from $v$ but not via a visibility edge but instead via an edge of that obstacle.
				\item[valid angle area] A \term{valid angle area} describes a specially determined angular range around a vertex in which potential visibility neighbors are checked.
			\end{description}
		
		\subsubsection{Parameter $k$ and consequences on the shortest paths}
		
			The $k$, however, is not just a single parameter, but rather a tuple of two separate values:
			The number of bins $k_b$ and the number of maximum neighbors per bin $k_n$.
			This means a maximum of $k_b \cdot k_n$ many neighbors are considered.
			
			Each bin covers a certain angle area of the currently processed vertex, for example for a bin count of 36, each bin would cover a 10° area.
			In fact, the chosen default values of 36 bins with ten neighbors per bin worked well in all and usages of the implementation.
			When a bin is full and a new edge should be inserted, an existing edge might be removed from the bin.
			The criterion on which edge to remove is its length such that only the $k_n$ shortest edges per angle area of the bin remain.
			Since shortest paths are wanted, storing the $k_n$ longest edges would result paths that are too long.
			
			Without this subdivision into bins and by only considering a static maximum number of neighbors, i.e. with $k$ being a single value, it is possible to only have edges to complex and close objects but no edges to obstacles further away.
			In other words, the edges would not be distributed evenly around a vertex.
			
			An example for this would be a building next to a large and open park.
			The $n$ nearest neighbors of the house are probably quite close, for example vertices of other houses, hedges or fences.
			This means that the far away other side of the park is not withing the set of neighbors, even though the other side of the park is clearly visible.
			Subdividing the neighbors into bins ensures that there will definitely be connections to the other side of the park.
			
			Generally restricting the number of neighbors and therefore reducing the number of edges leads to less accurate routing results, i.e. to suboptimal paths, which are not shortest.
			As mentioned above, one bin only contains the $k_n$ shortest edges to its neighbors.
			The significance of the negative impact due to this restriction, however, is debatable.
			In the case of using the above mentioned default values of ten edges per 10° range, an omitted edge led to a similar direction as at least nine other edges did.
			The negative influence of a detour to the total route length by using the next best edge towards the destination is most likely not significant.
			\todo{Check this in evaluation! Test: ca. 17\% of edges are removed with $(36,10)$ compared to $(3600,1000)$ with only 13\% longer calculation time}
			
		\subsubsection{Convex hull}
		\label{subsubsec:convex-hull}
			
			As mentioned in \hyperref[subsec:step-1-preprocessing]{step 1}, only visibility neighbors for vertices lying on the convex hull of any obstacle are determined.
			The visibility neighbors themselves also have to be on any convex hull, which means vertices not being on any convex hull will never be connected to other vertices.
			This filtering strategy is a simple performance enhancement with some implications on the route quality as discussed below.
			
			The reason for this filtering is quite simple:
			Vertices not being on a convex hull will never be part of a shortest path.
			This is the case, since the convex hull itself is by definition the smallest set of points that creates an areas, which in turn contains all other points of the geometry \cite[2]{de-berg-computational-geometry}.
			Interpreting the convex hull as one possible path around a shape, the triangle inequality implies that this path is in deed the shortest path around the shape.
			When determining shortest paths, the part of a route bending around an obstacle will therefore always be a subset of its convex hull.
			
			Of course, a routing query might start within a concave part of the obstacle or somewhere completely else.
			This case, however, is independent of the graph generation and belongs to answering routing queries, which is covered later in \cref{sec:answering-queries}.
			
			Also, the weighting function for the routing queries might not determine shortest, but for example fastest routes.
			In such case, the above filtering might result in inaccurate and suboptimal paths.
			Since this is just a performance enhancement and therefore an optional step, deactivating this filtering increases preprocessing time but solves this inaccuracy problem.
						
		\subsubsection{Valid angle areas}
			
			As mentioned above, a subsection of a shortest path bending around an obstacle always follows a part of the obstacle's convex hull.
			Eventually the path switches from following the convex hull to following a visibility edge, which leads to another obstacle and therefore another convex hull part.
			
			This means, a shortest path consists of many convex hull parts that either are connected by straight lines or touch each other.
			Connecting lines, i.e. line segments connecting one convex hull part with another, always follow the clockwise or counter clockwise direction of the line segments of each convex hull as illustrated in \cref{fig:convex-hull}.
			If the convex hull part bends in counter clockwise direction, it means that the bearing of each line segment decreases and increases for clockwise hulls respectively.
			In other words, line segments of a counter clockwise convex hull only make left turns, the ones of a clockwise hull only make right turns.
			The connecting line to the next convex hull follows this turning direction.
			Another way to think about this is the following with \cref{fig:convex-hull} as an example:
			if the destination vertex $v_2$ of the connecting line $(v_1, v_2)$ would be added to the obstacle of the source vertex (in this example $o_1$), then the connecting line would be part of the convex hull of this new expanded obstacle.
			Since the convex hull is the shortest path around an obstacle, the path $(v_0, v_1, v_2)$ is the shortest path on the expanded obstacle from $v_0$ to $v_2$ since it is a part of its convex hull.
			Because $v_2$ is not actually part of $o_1$, it means the path $(v_0, v_1, v_2)$ is generally the shortest from $v_0$ to $v_2$.
			Only connecting lines, which fulfill this expansion criterion, can be part of any shortest path.
			Furthermore, this criterion is only fulfilled for connecting lines following the turning direction of the obstacle, as $(v_1, v_2)$ does for the hull of $o_1$.

			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\coordinate (c00) at (0,0.4);
						\draw (c00)
							-- ++(2.75,-0.2) coordinate (c01)
							-- ++(0.8,0.4) coordinate (c02)
							-- ++(0.1,0.8) coordinate (c03)
							-- ++(-2,0) coordinate (c04)
							-- ++(-1.4,-0.35) coordinate (c05)
							-- (c00);
						\node[above right = 0.15 and 1.6 of c00] {$o_1$};
							
						\coordinate (c10) at (2.5,3.85);
						\draw (c10)
							-- ++(-0.4,-0.4) coordinate (c11)
							-- ++(0.1,-0.6) coordinate (c12)
							-- ++(2.8,0) coordinate (c13)
							-- ++(-0.4,1.2) coordinate (c14)
							-- (c10);
						\node[below right = 0.25 and 0.75 of c10] {$o_2$};
						
						\def\d{1.5\pgflinewidth}
						\filldraw[thin,Green4!35!white] ($(c03)+(0,\d)$) -- +(180:0.35) arc [start angle=180, delta angle=-97.126, radius=0.35];
						\draw[thin,Green4] (c03) -- (intersection of c03--[shift=(c03)]82.874:3 and c12--c13);
						\draw[thin,Green4] ($(c03)+(0,\d)$) -- +(180:4);
%							
						\filldraw[thin,DodgerBlue3!35!white] ($(c12)+(0,-\d)$) -- +(279.462:0.4) arc [start angle=279.462, delta angle=80.538, radius=0.4];
						\draw[thin,DodgerBlue3] (c12) -- (intersection of c12--[shift=(c12)]279.462:1 and c03--c04);
						\draw[thin,DodgerBlue3] ($(c12)+(0,-\d)$) -- +(0:4);
						
						\tikzDot[label={right:$s$}]{(c01)}{s}
						\tikzDot[label={right:$v_0$}]{(c02)}{v0}
						\tikzDot[label={right:$v_1$}]{(c03)}{v1}
						\tikzDot[label={left:$v_2$}]{(c12)}{v2}
						\tikzDot[label={below:$v_3$}]{(c13)}{v3}
						\tikzDot[label={left:$t$}]{(c10)}{t}
						
						\draw[->,Red2,thick] (s) -- (v0);
						\draw[->,Red2,thick] (v0) -- (v1);
						\draw[->,Red2,thick] (v1) -- (v2);
						\draw[->,Red2,thick] (v2) -- (c11);
						\draw[->,Red2,thick] (c11) -- (t);
					\end{tikzpicture}
				\end{figcenter}
				\caption{The path from $s$ via $v_1$ and $v_2$ to $t$ bends along the convex hulls of $o_1$ and $o_2$.
					The segment from $v_1$ to $v_2$ is a connecting line between the hull parts.
					% Suppose $v_2$ would be part of $o_1$, then the path from $s$ via $v_1$ to $v_2$ would be on its convex hull. Same holds true for $v_1$ and $o_2$ respectively.
					\\
					The green angle at $v_1$ indicates one angle area in which all visibility neighbors of $v_1$, in case they would be added to $o_1$, would expand $o_1$'s convex hull without removing $v_1$ from it. Same applies to the blue angle for $o_2$ and $v_2$ respectively.
					\\
					Vertex $v_3$, however, is not a potential neighbor for $v_1$.
					Adding it to $o_1$ would not only remove $v_1$ from $o_1$'s convex hull but would also remove $v_1$ from the shortest path.}
				\label{fig:convex-hull}
			\end{figure}
			
			Allowing connecting lines against the turning direction of the source obstacle hull would result in edges that will never be part of a shortest path.
			For example, the line segment $(v_1, v_3)$ in \cref{fig:convex-hull} is not part of any shortest path, which has $v_1$ is an intermediate vertex.
			This is due to the properties described at the beginning:
			convex hulls themselves build shortest paths around obstacles, the overall shortest path is a sequence of convex hull parts, connecting lines connect these hull parts by following their turn direction and therefore they are part of the overall shortest path as well.
			Breaking the criterion of the turn directions, i.e. by allowing connecting lines against the turn direction of the source hull, leads to non-shortest paths.
			This connecting line, which was created against the hull's turning direction, can be relaxed to a new connecting line that follows the turning direction and is shorter due to the triangle inequality.
			In \cref{fig:convex-hull}, the path $(v_0, v_1, v_3)$ with the connecting line $(v_1, v_3)$, which turns to the right even though $o_1$'s hull turns to the left, can be relaxed to $(v_0, v_3)$ forming the actual shortest path.
			
			Following the idea of expanding the source obstacle illustrates the contradiction that appears for breaking the turn direction criterion.
			Considering the obstacle $o_1$ and expanding it with the candidate vertex $v_3$ to $o'_1=o_1 \cup \{v_3\}$ yields the path $(s, v_0, v_3)$, which is the shortest path for the actual existing obstacles from $s$ to $v_3$, because it follows the convex hull of the hypothetical obstacle $o'_1$.
			Assume the segment $(v_1, v_3)$, created against $o_1$'s and $o'_1$'s convex hull turning direction, would be part of the shortest path from $s$ to $v_3$.
			In this case, which means the path would be $(s, v_0, v_1, v_3)$, the vertex $v_1$ would not be part of the convex hull of $o'_1$.
			The hull of $o'_1$, however, is in fact the shortest path around $o'_1$, meaning it contains the shortest path from $s$ to $v_3$ since both vertices are on its convex hull.
			Because $(v_1, v_3)$ is \emph{not} part of this convex hull, it cannot be part of the shortest path.
			Thus, creating connecting lines against the turning direction of the source obstacle creates lines, which are not part of any shortest path.
			
			Only connecting lines fulfilling the above described turning direction criterion need to be considered, which restricts the relevant vertices to certain angular ranges.
			The marked green and blue angle areas in \cref{fig:convex-hull} represent these \term{valid angle areas} for potential visibility neighbors.
			Vertices at other angles will be ignored since the resulting edges will never be part of any shortest path.
			
			Since this is solely a performance optimization, the same considerations apply as in the above shown convex hull filtering.
			As soon as the weighting function is not creating a shortest path, this optimization might lead to suboptimal paths.
			Again, removing this optimization solves this problem.
			
		\subsubsection{Intersection checks}
		\label{subsubsec:intersection-checks}
			
			All intersection checks are performed using own implementations instead of method from the the NetTopologySuite, which are more generalized and therefore slower.
			\todo[inline]{Evaluation by executing 10k (or so) random collision checks with several other method from NTS (s. wekan ticket)}
			In fact, there are two types of intersection checks implemented:
			One function to check for an intersection between two arbitrary line segments and one to check if a point lies within a triangle.
			
			The line segment intersection check uses an approach based on cross products as presented in \emph{Introduction to algorithms} by Thomas H Cormen et al. \cite[1018]{cormen-introduction-to-alg}.
			Even though this method only works on single line segments, it is significantly faster than general purpose checks provided by the NetTopologySuite.
			This is still true when checking if a single line segments intersects any of multiple obstacles.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\tikzDot[label={below left:$(1,0,0)$}]{(0,0)}{a}
						\tikzDot[label={below right:$(0,1,0)$}]{(4,0)}{b}
						\tikzDot[label={above:$(0,0,1)$}]{(2,3)}{c}
						
						\coordinate[between={a and c}] (ac);
						\coordinate[between={b and c}] (bc);
						\coordinate[between={a and b}] (ab);
						
						\draw (a) -- (b);
						\draw (a) -- (c);
						\draw (b) -- (c);
						
						\draw[dotted] (a) -- (bc);
						\draw[dotted] (b) -- (ac);
						\draw[dotted] (c) -- (ab);
						
						\tikzDot{(intersection of a--bc and b--ac)}{center};
						\node[below=1mm of center,inner sep=0mm,fill=white] {$c=(\nicefrac{1}{3},\nicefrac{1}{3},\nicefrac{1}{3})$};
						
						\tikzDot[label={left:$a=(0.5,0,0.5)$}]{(ac)}{left}
						\tikzDot[label={right:$b=(-0.2,0.5,0.7)$}]{(3.4,2.1)}{right}
					\end{tikzpicture}
				\end{figcenter}
				\caption{A triangle with barycentric coordinates and dotted lines for the three coordinate axes. Noteworthy is coordinate $b$ as it is outside the triangle, which can be directly seen from the negative value $-0.2$.}
				\label{fig:barycentric-triangle}
			\end{figure}
			
			Checking if a vertex lies inside a triangle is done by a barycentric collision check and used for closed obstacles, which got triangulated during \hyperref[subsec:step-1-preprocessing]{preprocessing}.
			This method creates a barycentric coordinate system in which each coordinate has the form $(\lambda_1,\lambda_2,\lambda_3)$.
			For each corner of the triangle, exactly one value of the coordinate is one and the other two values are zero.
			\Cref{fig:barycentric-triangle} illustrates this with some exemplary points.
			Due to the properties of this coordinate system, a point $p$ is inside the triangle when the condition $0 < \lambda_i < 1$ is satisfied for each of the three values.
			Even though it sounds complex to create a whole coordinate system for a single collision check, this method only uses a few basic arithmetic operations and is therefore very fast.
			
		\subsubsection{Shadow area operations}
			
			The shadow areas are stored in the previously described \hyperref[subsec:binindex]{BinIndex} data structure.
			Inserting of the intervals therefore works as described in \cref{subsec:binindex}.
			
			Shadow areas are always determined for a single vertex $v$.
			Checking if a different vertex $u$ is within any shadow area, and therefore not visible from $v$, is quite simple.
			First, all shadow areas are queried that fall into the bin of the $u$'s angle.
			Second, for each shadow area $s$ it is checked whether $u$ is at least a far away from $v$ as the minimum distance of $s$ and whether the vertex is exactly within the angle area of $s$.
			If both holds true for any such shadow area $s$, then $u$ is not visible from $v$.
		
		\subsubsection{Visibility graph generation overview}
		
			The performed steps of determining the visibility neighbors are the following.
			Each step is described with more details in the sections below.
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.},label={2.\arabic*.}]
				\item Determine the obstacle neighbors for each vertex.
				\item For each vertex $v$ lying on any convex hull, determine its visibility neighbors.
%				\begin{enumerate}
%					\item For each other vertex $u$, do the following:
%					\begin{enumerate}
%						\item Is $u$ in any shadow area \emph{or} not on any convex hull \emph{or} not in any valid angle area? If so: $u$ is not relevant, move to the next other vertex.
%						\item Query all obstacles between $v$ and $u$. This is done by the bounding box spanned by $v$ and $u$.
%						\item Create and store the shadow area of each such obstacle $o$.
%						\item Check if $u$ is a visibility neighbor, which is true if $u$ is a) still not in any shadow area and b) the line segment from $v$ to $u$ intersects with none of the above queries obstacles.
%					\end{enumerate}
%				\end{enumerate}
				\item Sort the visibility neighbors into bins based on the obstacle neighbors.
			\end{enumerate}
		
		\subsubsection{Step 2.1: Determining obstacle neighbors}
			
			Obstacle neighbors are needed to correctly handle the closed surface of obstacles, especially when two obstacles tough each other.
			This handling of neighbors is then used to form the valid angle areas, which in turn are used to determine whether a distant vertex is relevant for visibility checks.
			
			Determining the obstacle neighbors is relatively simple and straight forward.
			Each vertex $v$ of an obstacle $o$ is processed by looking at the previous and next vertices $v_p$ and $v_n$ on the same obstacle, which are both potential obstacle neighbors.
			If the line segment $(v, v_p)$, same applies to $v_n$, does not intersect with any other obstacle and is not an edge on any other obstacle, it is considered an obstacle neighbor.
			Latter case can be seen in \cref{fig:obstacle-neighbors-touching} at the line segment $(v_1, v_3)$, which is part of two touching obstacles.
						
			\begin{figure}[h]
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot[label={[text=gray]below:$v_0$},gray]{(0,0)}{v0}
							\tikzDot[label=above:$v_1$]{(1,1.5)}{v1}
							\tikzDot[label=below:$v_2$]{(2,0)}{v2}
							\tikzDot[label=above:$v_3$]{(3,1.5)}{v3}
							\tikzDot[label={[text=gray]below:$v_4$},gray]{(4,0)}{v4}
							
							\draw[gray] (v0) -- (v1);
							\draw[->,very thick] (v2) -- (v1);
							\draw[->,very thick] (v2) -- (v3);
							\draw[gray] (v3) -- (v4);
						\end{tikzpicture}
					\end{figcenter}
					\caption{The black lines show the obstacle neighbors of $v_2$, which are $v_1$ and $v_3$.}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\def\d{1.5}
							
							\tikzDot[gray]{(0,0)}{c00}
							\tikzDot[label=above:$v_0$]{(0,\d)}{v0}
							\tikzDot[label=above:$v_1$]{(\d,\d)}{v1}
							\tikzDot[label=above:$v_2$]{(2*\d,\d)}{v2}
							\tikzDot[label={[text=gray]below:$v_3$},gray]{(\d,0)}{v3}
							\tikzDot[gray]{(2*\d,0)}{c20}
							
							\node at (0.5*\d,0.5*\d) {$o_1$};
							\node at (1.5*\d,0.5*\d) {$o_2$};
							
							\draw[gray] (c00) -- (v0);
							\draw[gray] (c00) -- (v3);
							\draw[->,very thick] (v1) -- (v0);
							\draw[->,very thick] (v1) -- (v2);
							\draw[->,gray] (v1) -- (v3);
							\draw[gray] (c20) -- (v3);
							\draw[gray] (c20) -- (v2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{The black lines show the obstacle neighbors of $v_1$, which are $v_0$ and $v_2$. The vertex $v_3$ is a neighbor as well, but hidden due to the touching obstacles $o_1$ and $o_2$ and therefore not an obstacle neighbor.}
					\label{fig:obstacle-neighbors-touching}
				\end{minipage}
			\end{figure}
			
			Because the step of determining the obstacle neighbors is very important for finding all relevant visibility neighbors, the implementation is within the \texttt{VisibilityGraphGenerator} class, namely the \texttt{AddObstacleNeighborsForObstacles} method.
			Each of the following steps is within this class as well, due to the close relationship.
			
		\subsubsection{Step 2.2: Determining visibility neighbors}
		
			As mentioned above, the \texttt{VisibilityGraphGenerator} class also contains the necessary methods to determine the visibility neighbors for every vertex.
			Essential to this process is the \texttt{GetVisibilityNeighborsForVertex} method determining the visibility neighbors for a single vertex.
			This method uses the concept of shadow areas stored in a BinIndex structure with a bin count of 360, each bin covering a 1° area.
%				Additionally, all obstacles casting a shadow are separately stored, simply to check whether or not a obstacle already casts a shadow.
%				Since querying of obstacles is necessary, they are stored in a QuadTree.
			
			The following steps are performed for every vertex $v$ being part of any convex hull.
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.},label={2.2.\arabic*.}]
				\item Continue with the next vertex if any of these conditions is true (otherwise process with the next step): Vertex $u$ is in a shadow area \emph{or} $u$ is outside a valid angle area \emph{or} $u$ is not part of any convex hull.
				\item Query all obstacles in the extent spanned by $v$ and $u$. For each obstacle $o$ the following steps are performed:
				\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.}-1em]
					\item Get or create the shadow area for $o$.
					\item If a new shadow area $S$ was just created \emph{and} $u \in S$, \emph{then} mark $u$ as hidden and skip all subsequent obstacles and continue with the next vertex.\label{itm:if-u-not-on-obstacle}
					\item At this point $u \not\in S$, so if $u$ is within the angular range of the obstacle as seen from $v$ \emph{and} there is an intersection of $o$ with the line segment $(v, u)$ (using the methods described above in \emph{\nameref{subsubsec:intersection-checks}}), \emph{then} mark $u$ as hidden.
				\end{enumerate}
				\item If $u$ has been marked as hidden, continue with the next vertex.
				\item If $u$ is visible, store it in the according bin for its angle and continue with the next vertex
			\end{enumerate}
			Having all visibility neighbors according to the amount and size of the bins, they are sorted in new bins based on the obstacle neighbors.
			This procedure is described in the following section and its result is stored for the graph creation, which is described below in \cref{subsec:step-3-graph-creation}.
		
		\subsubsection{Step 2.3: Sort resulting visibility neighbors into bins}
		
			A naive approach to create a visibility graph would be to create edges between vertices that are visible to each other.
			This would make routing through line-based obstacles possible as \cref{fig:routing-through-line-obstacle} illustrates.
			Such routing behavior is, of course, not desired.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\tikzDot{(2,0)}{vo0};
								\tikzDot[label={[label distance=-1.25mm]above right:$v $}]{(2,1)}{vo1};
								\tikzDot{(2,2)}{vo2};
								
								\draw (vo0) -- (vo1);
								\draw (vo1) -- (vo2);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo1);
								\draw[dotted] (vo1) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption{
							Visibility graph with naive connections.
							The two visibility edges at $v$ allow the shortest path to go through the obstacle from $n_a$ via $v$ to $n_b$.
						}
						\label{fig:routing-through-line-obstacle-a}
					\end{subfigure}
					\hfill
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\def\r{0.85mm}
								\def\rMargin{1.1mm} % = r + 0.25mm
								\def\gap{0.1875mm}
								
								\tikzDot{(2,0)}{vo0};
								\node (vo1) at (2,1) {};
								\node[label={[label distance=-1.25mm]above left:$v_a$}] at (vo1) {};
								\node[label={[label distance=-1.25mm]above right:$v_b$}] at (vo1) {};
								\coordinate (vo11) at ($(vo1)+(180:\rMargin)$);
								\coordinate (vo12) at ($(vo1)+(0:\rMargin)$);
								\tikzDot{(2,2)}{vo2};
								
								\filldraw (vo1)++(-\gap,0)++(90:\r) arc (90:270:\r);
								\filldraw (vo1)++( \gap,0)++(90:\r) arc (90:-90:\r);
								
%								\draw (vo1)++(270:\rMargin) -- (vo0);
								\draw ($(vo1)+(270:\r)+(-0.275mm,0)$) -- ($(vo0)+(-0.275mm,2mm)$) -- (vo0.north);
								\draw ($(vo1)+(270:\r)+( 0.275mm,0)$) -- ($(vo0)+( 0.275mm,2mm)$) -- (vo0.north);
%								\draw (vo1)++(90:\rMargin) -- (vo2);
								\draw ($(vo1)+(90:\r)+(-0.275mm,0)$) -- ($(vo2)+(-0.275mm,-2mm)$) -- (vo2.south);
								\draw ($(vo1)+(90:\r)+( 0.275mm,0)$) -- ($(vo2)+( 0.275mm,-2mm)$) -- (vo2.south);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo11);
								\draw[dotted] (vo12) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption{
							The visibility graph with connection respecting the obstacle. Vertex $v$ is split into two, $v_a$ and $v_b$, with exact same location. All gaps are for illustration purposes only.
							Vertex $v_a$ is connected to $n_a$ and $v_b$ to $n_b$ but $v_a$ and $v_b$ are not connected.
							This ensures that the shortest path from $n_a$ to $n_b$ does not lead through the middle vertex of the obstacle anymore.
						}
						\label{fig:routing-through-line-obstacle-b}
					\end{subfigure}
				\end{figcenter}
				\caption{
					Both illustrations show two of $v$'s visibility neighbors $n_a$ and $n_b$ next to a vertical obstacle. Routing through this obstacle should \emph{not} be possible.
					The dotted edges are visibility edges, the solid edges normal line segments of the obstacle.
				}
				\label{fig:routing-through-line-obstacle}
			\end{figure}
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\def\d{0.03}
						
						\tikzDot[label=below:$v$]{(0,0)}{v}
						
						\tikzDot[label=left:$n_1$]{(-2.25,0)}{n1}
						\tikzDot[label=above:$n_2$]{(0,2)}{n2}
						\tikzDot[label=right:$n_3$]{(2.25,0)}{n3}
						
						\draw[lightgray] (v) -- (n1);
						\draw[lightgray] (v) -- (n3);
						\draw[lightgray] (v) -- (n2);
						
						% Visibility edges to n1
						\tikzDot[DodgerBlue3]{(-1.1,-0.25)}{vn1}
						\tikzDot[DodgerBlue3]{(-1.6,-0.9)}{vn2}
						\tikzDot[DodgerBlue3]{(1.6,-0.5)}{vn3}
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn1);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn2);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn3);
%							\draw[DodgerBlue3,densely dashed,->] ($(v)+(-0.075,-\d)$) -- ($(n1)+(0.075,-\d)$);
%							\draw[DodgerBlue3,densely dashed,->] ($(v)+(0.075,-\d)$) -- ($(n3)+(-0.075,-\d)$);
						
						% Visibility edges to n3
						\tikzDot[Red2]{(0.7,1.4)}{vn4}
						\tikzDot[Red2]{(2,1)}{vn5}
						\draw[Red2,densely dotted,->] (v) -- (vn4);
						\draw[Red2,densely dotted,->] (v) -- (vn5);
%							\draw[Red2,densely dotted,->] ($(v)+(0.075,\d)$) -- ($(n3)+(-0.075,\d)$);
%							\draw[Red2,densely dotted,->] ($(v)+(\d,0.075)$) -- ($(n2)+(\d,-0.075)$);
						
						% Visibility edges to n2
						\tikzDot[Green4]{(-2,1.3)}{vn6}
						\draw[Green4,dashdotted,->] (v) -- (vn6);
%							\draw[Green4,dashdotted,->] ($(v)+(-\d,0.075)$) -- ($(n2)+(-\d,-0.075)$);
%							\draw[Green4,dashdotted,->] ($(v)+(-0.075,\d)$) -- ($(n1)+(0.075,\d)$);
					\end{tikzpicture}
				\end{figcenter}
				\caption{All visible neighbors of $v$ colored by their resulting bin. The neighbors $n_1$, $n_2$ and $n_3$ are also sorted into bins but they occur in each adjacent bin. The means $n_2$ is in the bin for area $n_1$/$n_2$ as well as in the bin for $n_2$/$n_3$.}
				\label{fig:visibility-bin-sorting}
			\end{figure}
			
			To correctly split and connect vertices, as illustrated for vertex $v$ in \cref{fig:routing-through-line-obstacle}, it must be known which visibility neighbors are within the angular range of which adjacent obstacle neighbors.
			Knowing this enables the graph generation to sort all visibility neighbors into bins, as shown in \cref{fig:visibility-bin-sorting}.
			Each of the resulting bins of a vertex $v$ covers the area between two adjacent obstacle neighbors.
			Later, in \hyperref[subsec:step-3-graph-creation]{step 3}, each bin leads to one new vertex.
			In the mentioned illustration, there would be two bins, one containing $n_a$ and one containing $n_b$, leading to two new vertices $v_a$ and $v_b$.
			
	\subsection{Step 3: Visibility graph creation}
	\label{subsec:step-3-graph-creation}
	
		The previous step created the raw data that is needed to generate a routable visibility graph, which is done in this third step.
		Since the \texttt{SpatialGraph} class in the NetTopologySuite uses the term \emph{node}, the term \emph{vertex} in this section refers to the vertices in the result of step 2, the term \emph{node} refers to the nodes in the output graph.
		
		As described at the end of the previous step, one node is created for each bin of neighboring vertices.
		Therefore, mappings between nodes, vertices and neighbor bins have to be created.
		For an example, consider \cref{fig:routing-through-line-obstacle-b} where neighbor vertex $n_a$ should be connected to $v$.
		Since $v$ is split into two vertices, two nodes are created in the graph and therefore a mapping from node to bin is needed in order to connect the right nodes with each other.
		Two iterations over all vertices are used to first create the nodes with the respective bin-mapping and then, in the second iteration, this mapping is used to correctly connect all nodes.
		
		Without this mapping, it would not be clear to what node to connect.
		As the example in \cref{fig:routing-through-line-obstacle} shows, without a mapping between visibility neighbor bins and nodes, it is unclear whether to connect $n_a$ to $v_a$ or to $v_b$ because they both are on the exact same location.
		
		The resulting spatial graph together with some of the mappings, which will be used to \hyperref[sec:answering-queries]{answer routing queries}, are stored in an instance of the \texttt{HybridVisibilityGraph} class.
		It contains the final spatial graph, as an instance of the \texttt{SpatialGraph} class provided by the MARS framework, along with all information needed to correctly add and connect new nodes.
		Adding nodes is only used for the start and destination locations of a routing query.
		
	\subsection{Step 4: Merging a road network into the visibility graph}
	\label{subsec:step-4-graph merging}
	
		To allow a routing algorithm to switch between the road network and visibility edges, the road network needs to be merged into the visibility graph.
		This happens not just by adding the road segments to the graph but by introducing and connecting new nodes at all intersections between road and visibility edges.
		\Cref{fig:merging-edges} illustrates this process for one road segment and two visibility edges.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\draw[<->,dashed] (v1n1) -- node[above right=0cm and 0.4cm] {$v$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above right=0cm and 0.4cm] {$u$} (v2n2);
							
							\draw[<->] (rn1) -- node[left] {$r$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{
						Before merging $r$ into the graph with a total of six nodes and six edges.
					}
					\label{fig:merging-edges-a}
				\end{subfigure}
				\hfill
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\tikzDot{(intersection of v1n1--v1n2 and rn1--rn2)}{i1}
							\tikzDot{(intersection of v2n1--v2n2 and rn1--rn2)}{i2}
							
							\draw[<->,dashed] (v1n1) -- node[above] {$v_1$} (i1);
							\draw[<->,dashed] (i1)   -- node[above] {$v_2$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above] {$u_1$} (i2);
							\draw[<->,dashed] (i2)   -- node[above] {$u_2$} (v2n2);
							
							\draw[<->] (rn1) -- node[right] {$r_1$} (i1);
							\draw[<->] (i1)  -- node[right] {$r_2$} (i2);
							\draw[<->] (i2)  -- node[right] {$r_3$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{
						After merging $r$. Two new vertices have been created and all edges are split on the intersection points. The graph size therefore increased by two nodes and eight edges (since all edges are bidirectional) to eight nodes and 14 edges.
					}
					\label{fig:merging-edges-b}
				\end{subfigure}
			\end{figcenter}
			\caption{
				Merging the road edge $r$ with two bidirectional visibility edges $v$ and $u$.
			}
			\label{fig:merging-edges}
		\end{figure}
	
		This final graph allows any routing algorithm to switch between road and visibility edges without further instructions or adjustments to the routing algorithm.
		

		With $E_R$ containing all road and $E_V$ all visibility edges, the complexity of the merge operation is within $\bigo{|E_R| \cdot |E_V|}$.
		This complexity arises from the fact that a road segment intersecting with $n$ visibility edges leads to $n+1$ new road segments, $n$ new intersection points and $n$ new visibility edges connecting them.
		In the worst case of a road segment intersecting with all visibility edges, $2 \cdot |E_V| + 1$ edges and $|E_V|$ nodes are added to the graph.
		Therefore, up to $|E_R| \cdot (2 \cdot |E_V| + 1)$ new edges and $|E_R| \cdot |E_V|$ new nodes are created.
		Even though it does not scale worse than linear in the input size $|E_R|$ of the road edges, the size of the output graph is significantly higher than the input road network, which are typically quite sparse networks.

		Measured graph sizes and effects on the routing performance are presented and discussed in \cref{chap:evaluation}.
	
\section{Answering shortest path queries}
\label{sec:answering-queries}

	The process of answering shortest path queries, or routing queries in general, is directly implemented in the \texttt{HybridVisibilityGraph} class.
	Arbitrary weighting functions can be passed to customize the routing behavior.
	Implementing the core idea of determining routes between arbitrary location is, with the help of the above described techniques, rather simple:
	\begin{enumerate}
		\item \label{itm:answering-queries-add-nodes} Add nodes for the source and destination locations of the routing query to the graph.
		\item \label{itm:answering-queries-vis-edges} Determine visibility edges of each of the two nodes and merge these new edges into the graph.
		\item \label{itm:answering-queries-routing} Use a normal shortest path algorithm, such as A*, to find the path from the source to the destination.
		\item \label{itm:answering-queries-cleanup} Remove all previously added nodes and edges to get a clean graph for future routing requests.
	\end{enumerate}
	Step \ref{itm:answering-queries-add-nodes} creates two new nodes in the spatial graph as far as no node already exists at the respective location.
	
	Because step \ref{itm:answering-queries-vis-edges} is already implemented for the general graph generation, the core method \texttt{VisibilityGraphGenerator.GetVisibilityNeighborsForVertex()} can be reused without further adjustments.
	The most complex part is to determine the correct node to connect to.
	Thanks to the mappings of neighbor bins and their covered angle areas, as introduced in \cref{subsec:step-3-graph-creation}, the correct bin for a location can be determined and a bidirectional edge be created.
	These are mostly simple filtering operations on the bins and can be implemented with very little code.
	
	Fortunately, the \texttt{SpatialGraph.RemoveNode(int)} method removes the node given by its ID and also removes all edges, which are connected to the given node.
	This makes step \ref{itm:answering-queries-cleanup} very easy since step \ref{itm:answering-queries-add-nodes} and \ref{itm:answering-queries-vis-edges} yield the IDs of created nodes, which are needed for the cleanup.
	
	\todo{Summary/wrap up/transition to evaluation chapter}