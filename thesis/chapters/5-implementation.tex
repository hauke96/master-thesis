% !TEX root = ../thesis.tex
% !TeX spellcheck = en_US

This section describes more implementation details of the previously described approach.
First, an overview of the algorithm with a short description of used frameworks and technologies is given.
After that, the main sections of this chapter show details of each algorithmic step.

\section{Algorithm overview}

	\subsection{Frameworks and technology}
	
		As mentioned in \cref{subsec:constrains} about the constrains, the used programming language is C\# due to the dependency to the MARS framework.
		The MARS framework is based on the widely used C\# library \term{NetTopologySuite} (\term*{NTS}), which contains numerous data structures, algorithms and helper function to handle and process geospatial data.
		
		The NTS was primarily used for basic data structures like features and geometries.
		Writing data to files is also done using NTS functions to serialize the geospatial data into GeoJSON files.
		
		The \term*{MARS} framework was also used for basic data structures, like the \texttt{Position} class.
		However, higher level structures like quadtrees and mathematical calculations were used as well.
		
		Not all data structures and algorithms already existed to create the hybrid routing graph.
		Most notably, a fast line intersection check was implemented as well as a bin based index structure.
		Several other helper functions and simpler structures, like a separate class for vertices, were added as well.

	\subsection{Early implementation based on the continuous dijkstra paradigm}
	
		An early implementation was not creating a visibility graph but instead it was based on the \term*{continuous dijkstra} paradigm with wavelets propagating through open spaces.
		However, there were two reasons why this first approach was replaced by a visibility graph based algorithm.
		
		The first reason was a bad performance.
		Early stages of the continuous dijsktra approach used a very naive and simple implementation without optimizations mentioned in recent literature on this topic.
		Before investing larger efforts into the implementation of a more complex approach, like the one presented by Hershberger and Suri\cite{hershberger-suri}, a simple preprocessing was introduced and lead to a major performance enhancement.
		This perprocessing determined the visibility between all vertices, which was later used to create events for the collision between wavelets and vertices.
		Such predetermined visibilities are the core of a visibility graph, thus moving to an actual visibility graph based approach was not a big step.
		
		The second reason to actually move towards a visibility graph was the difficulty and the disadvantages of combining the network based routing with the continuous dijkstra algorithm implemented so far, as described in \cref{sec:combining-routing-algorithms}.
		Therefore, the decision fell in favor of implementing and optimizing the creation of a routable visibility graph.
	
	\subsection{Chosen approach and potentially faster known algorithms}

		% Maybe this whole subsection is part of a later discussion?
		Due to the step by step development by turning the former continuous dijkstra preprocessing into a visibility graph generator, the implemented approach does not follow algorithms described in the literature.
		The performance of this implementation, as shown in \todo[inline]{link to chapter}, is still enough for practical use, but a well designed and fast algorithm, like the one presented by Overmars and Welzl \cite{overmars-weizl-visibility-graph} or the one by Ghosh and Mount \cite{ghosh-output-sensitive-vgraph}, would clearly increase performance.
		However, this performance enhancement would only affect the generation of a visibility graph and not the performance of the routing queries.
			
	\subsection{Algorithm steps}
		
		As describes in \cref{sec:components}, the \texttt{HybridVisibilityGraphGenerator} class provides a factory method to create a \texttt{HybridVisibilityGraph} from a given collection of features.
		This factory method consists of the following top level steps.
		\todo[inline]{more?}
		
\section{Visibility graph creation}
		
	\subsection{Step 1: Obstacle filtering and feature preprocessing}
	\label{subsubsec:step-1-preprocessing}
			
			First the features are filtered to get all relevant obstacle features, which are of arbitrary shape.
			For performance reasons, multi-geometries, like \texttt{MultiPolygon} are split up into their separate geometries.
			This is not only unproblematic for \texttt{MultiLineString} but also for \texttt{MultiPolygon} features, since holes in a polygon are not reachable in the first place and unwrapping the \texttt{MultiPolygon} will not change this.
			% TODO Better formulation?
			Another task within this first step is the triangulation of all polygonal shapes.
			The main reason is a better performance for intersection checks, which is an important task of creating a visibility graph.
			
	\subsection{Step 2: Determining $k$ nearest visible neighbors}
			
			After having all preprocessed obstacles, the main task of the visibility graph creation is performed, namely determining all $k$ many visible neighbors.
			Determining all visible neighbors would also be possible, but this parameter is an easy way to increase performance with the downside of not having all possible edges in the final routing graph.
			
			\subsubsection{Overview and terminology}
			
				Before describing the details on determining the $k$ nearest neighbors, there are some terms that need to be defined.
				
				\begin{description}
					\item[\term*{visibility neighbor}] Sometimes also just \emph{visible neighbor} is a vertex $u$ that is visible from the currently processed vertex $v$.
					\item[\term*{obstacle neighbor}] This is a vertex $u$ with an existing edge to or from the currently processed vertex $v$. In other words, $u$ is visible from $v$ but via an existing obstacle edge.
					\item[\term*{shadow area}] This is an angle area that starts at a certain distance, for example \enquote{10° to 20° with a minimum distance of 30 meter}.
				\end{description}
			
				\noindent The performed steps of determining the visible neighbors are the following, more details are given in the section below.
				\begin{enumerate}
					\item Get the obstacle neighbors for each vertex.
					\item For each vertex $v$, determine its visibility neighbors as follows.
					\begin{enumerate}
						\item For each other vertex $u$, do the following:
						\begin{enumerate}
							\item Is $u$ in any shadow area? If so, which means $u$ is not visible, move to the next other vertex. Continue otherwise.
							\item Query all obstacles between $v$ and $u$.
							\item Create and store the shadow area of each such obstacle $o$.
							\item Mark $u$ as visibility neighbors if $u$ is still not in any shadow area and a line segment from $v$ to $u$ intersects with none of the above queries obstacles.
						\end{enumerate}
						\item Sort visibility neighbors into bins based on the obstacle neighbors.
					\end{enumerate}
				\end{enumerate}
			
			\subsubsection{Parameter $k$}
			
				The $k$, however, is not just a single parameter, but rather consists of two separate values:
				The number of bins and the number of maximum neighbors per bin.
				Each bin covers a certain angle area of each vertex, for example for a bin count of 36, each bin would cover a 10° area.
				Without this subdivision of the neighbors, it is possible to only have edges to complex and close objects but no edges to obstacles further away.
				
				An example for this would be a large and open park where the $k$ nearest neighbors are probably all at the side of the park where the currently processed vertex is, even though the far away other side of the park is clearly visibly.
				This subdivision into bins ensure that there will definitely be connections to the other side of the park.
			
			\subsubsection{Determining obstacle neighbors}
				
				Determining the obstacle neighbors is relatively simple and straight forward.
				Each coordinate $c$ of an obstacle $o$ is processed by looking at the previous and next coordinates $c_p$ and $c_n$ on that obstacle, which are the potential neighbors.
				If the line segment $(c, c_p)$, for $c_n$ respectively, does not intersect with any obstacle, it is considered an obstacle neighbor.
				
			\subsubsection{Shadow areas}
			
				Shadow areas are a simple method to quickly determine vertices that are definitely not visible to each other.
				The idea of shadow areas is the following:
				Let $v$ be the currently processed vertex and think of it as a light bulb illuminating its surroundings.
				An obstacle $o$ casts a shadow outwards and everything within this shadow is definitely not visible from $v$.
				
				The distance from which everything within the angle area of the shadow is definitely not visible from $v$, is determined by the two bounding vertices (marked in red in \cref{fig:shadow-area}).
				These bounding vertices determine the angular range and the furthest of these two determines the minimum distance of the shadow area.
				
				Keeping track of these shadow areas for each vertex significantly improves performance.
				\todo[inline]{conrete numbers?}\todo[inline]{Reference to BinIndex below or other used data structure (s. TODO below)}
				% NetworkRoutingPlayground->Jungfernstieg dataset with 7916 vertices: ~7.3s with and 67s without shadow areas -> speed up of factor ~9
				% Hamburg inner city dataset with 67819 vertices: 382s with and ~31000s without shadow areas -> speed up of factor ~81
				
				\begin{figure}[h]
					\begin{center}
						\begin{tikzpicture}
							\def\angle{14.036}
							
							\tikzLabeledDot{(0,1.5)}{v}{$v$}
							\coordinate (shadow-arc-top)	at ($(v) +( \angle:2.5)$);
							\coordinate (shadow-arc-bottom)	at ($(v) +(-\angle:2.5)$);
							
							% Gray area
							\filldraw[lightgray] (shadow-arc-bottom) arc [start angle=-\angle, delta angle=28.072, radius=2.5] -- (6,3) -- (6,0) -- cycle;
							\draw[gray] (6,0) -- (shadow-arc-bottom) arc [start angle=-\angle, delta angle=28.072, radius=2.5] -- (6,3);
							
							\draw[dotted] (v) -- (shadow-arc-top);
							\draw[dotted] (v) -- (shadow-arc-bottom);
							
							% Faded gray area
							\filldraw[draw=none,lightgray,path fading=east] (7,3.25) -- (6,3) -- (6,0) -- (7,-0.25) -- cycle;
							\draw[gray,path fading=east] (6,3) -- (7,3.25);
							\draw[gray,path fading=east] (6,0) -- (7,-0.25);
							
							\tikzDot[red]{(shadow-arc-top)}{o10}
							\tikzDot{(3.25,1.5)}{o11}
							\tikzDot[red]{($(v) +(-\angle:1.75)$)}{o12}
							\node[above right = 0.2 and 0.5 of o12] {$o_1$};
							
							\tikzLabeledDot{(4.25,1.75)}{o20}{$v'$}
							\tikzDot{(3.5,0)}{o21}
							
							\node[darkgray] at (5.25,1.5) {\huge$S$};
							
							\draw (o10) -- (o11) -- (o12) -- (o10);
							\draw (o20) -- node[right] {$o_2$} (o21);
						\end{tikzpicture}
					\end{center}
					\caption{Shadow area $S$ cast by obstacle $o_1$ seen from vertex $v$. The vertex $v'$ of obstacle $o_2$ is not visible from $v$ since it lies inside the shadow area. The two red vertices of obstacle $o_1$ are the bounding vertices determining angle range and distance of $S$.}
					\label{fig:shadow-area}
				\end{figure}
				
			\subsubsection{BinIndex data structure}
			
				The \texttt{BinIndex} class implements a simple index structure to store and access intervals.
				It contains $n$ many bins of which each covers a certain range and consists of a linked list.
				When an item is added, it is added to each bin intersecting with the range of the item.
				Due to the list as underlying data structure for the bins, queries can be answered in $\bigo{m}$ time for $m$ many items in the index.
				
				The NetTopologySuite offers several indices specifically made for intervals, namely the \texttt{BinTree} and \texttt{SIRtree}, of which the latter one is static and does not allow insertions after the first query was made.
				Even though these two structures are tree based and theoretically offer a logarithmic query complexity compared to the linear complexity of the \texttt{BinIndex}, the simple and list based \texttt{BinIndex} is significantly faster even for larger datasets with tens of thousands of vertices.
				It is thinkable that the logarithmic complexity is useful for huge datasets with millions of vertices, but that has not been tested.
			
			\subsubsection{Intersection checks}
			
				All intersections are checked using own implementations no not rely on the generalized and therefore slower intersection checks of the NetTopologySuite.
				In fact, there are two types of intersection checks implemented:
				One check for intersection between two arbitrary line segments and one checks if a point lies within a triangle.
				This triangle check is used for closed obstacles, which got triangulated during \hyperref[subsubsec:step-1-preprocessing]{preprocessing}.
				
				The line segment intersection check uses a cross product based approach described in \emph{Introduction to algorithms} by Thomas H Cormen et al \cite[1018]{cormen-introduction-to-alg}.
				
				Checking if a point lies inside a triangle is done by a barycentric collision check.
				This method creates a barycentric coordinate system where each coordinate consists of three values $\lambda_1$, $\lambda_2$ and $\lambda_3$ for each corner vertex of the triangle.
				Due to the properties of this coordinate system, a point $p$ is inside the triangle when the condition $0 < \lambda_i < 1$ hold for each of the three values.
				Even though it sounds complex to create a whole coordinate system for a single collision check, this method only uses a few basic arithmetic operations and is therefore very fast.
			
			\subsubsection{Sort resulting visibility neighbors into bins}
			
				A naive approach to create a visibility graph would be to create edges between vertices that see each other.
				This would make routing through line based obstacles possible, which is of course not correct.
				It must therefore be known which visibility relations are between which obstacle neighbors.
				Knowing this enables the graph generation to distinguish between all the edges and results in correct routing results.
				More on this in the \cref{subsec:step-3-graph-creation} below.
				
				Each of the resulting bins of a vertex $v$ covers the area between two adjacent obstacle neighbors.
				All visibility neighbors are sorted into these bins, which is a simple and easy process.
			
	\subsection{Step 3: Graph creation with visibility edges}
	\label{subsec:step-3-graph-creation}
		
	\subsection{Step 4: Merging a road network into the visibility graph}

\section{Answering shortest path queries}