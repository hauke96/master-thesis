% !TEX root = ../thesis.tex
% !TeX spellcheck = en_US

This section covers details on the implementation of the previously described design.
First, an overview of the algorithm is given including a short description of used frameworks and technologies.
Second, two new and important data structures are described in detail.
Finally, each algorithmic step of the graph generation but also of the query answering is described in the main sections of this chapter.

\section{Algorithm overview}

	In this section, details on the code dependencies are given as well as a broad overview of the algorithm.

	\subsection{Frameworks and technology}
	\label{subsec:frameworks-technology}
	
		As mentioned in \Cref{subsec:constraints} regarding the constraints, the used programming language is C\# due to the dependency to the MARS framework.
		The MARS framework is based on the widely used C\# library \term{NetTopologySuite} (\term*{NTS}), which contains numerous data structures and algorithms to work with geospatial data.
		
		Primarily, the NTS was used for basic data structures like coordinates, geometries and features but also for calculations, e.g. the calculation of distances.
		Serialization of data is also done with the help of the NTS.
		The \term*{MARS} framework is also used, primarily for the \texttt{Position} class and high level structures such as the \texttt{SpatialGraph} or \texttt{QuadTree} classes.
		
		Not all data structures and algorithms already existed that were required to create the hybrid routing algorithm.
		Most notably, a \hyperref[subsubsec:intersection-checks]{fast line intersection check}, a \hyperref[subsec:binindex]{bin-based index} and a fast \hyperref[subsec:shadow-areas]{vertex filtering method} were implemented, which are all presented with more details in this chapter.
			
	\subsection{Algorithm steps}
	\label{subsec:algorithm-steps}
	
		This section presents the two main parts, the graph generation and the answering of routing requests, with their separate steps.
		
		\subsubsection{Graph generation}
		\label{subsubsec:graph-generation}
		
			The \texttt{HybridVisibilityGraphGenerator} class provides a factory method to create an instance of the \texttt{HybridVisibilityGraph} class from a given collection of features.
			This factory method consists of the following top level steps, which are all described in \Cref{sec:visibility-graph-creation} in more detail:
			\begin{enumerate}
				\item \hyperref[subsec:step-1-preprocessing]{Filter the given features for obstacles}
				\item \hyperref[subsec:step-2-knn-search]{Determine the visibility neighbors}
				\item \hyperref[subsec:step-3-graph-creation]{Use this visibility relation to create a visibility graph}
				\item \hyperref[subsec:step-4-graph merging]{Merge the existing road network into this graph}
			\end{enumerate}
			Answering routing queries between arbitrary locations, which are not part of the graph, is part of the next step.
		
		\subsubsection{Answering routing queries}
		
			To determine optimal paths between arbitrary locations, the resulting graph needs to be extended with edges from and to the given source and destination locations.
			These edges themselves are visibility edges and can therefore be created and merged just like the visibility edges before.
			Further details are given in \Cref{sec:answering-queries} describing the following steps:
			\begin{enumerate}
				\item Determine visibility edges for source and destination coordinates\label{itm:step-merging-source-dest}
				\item Merge these edges into the graph such that they can be removed afterwards
				\item Route along the resulting graph (e.g. by using the A* algorithm)
				\item Restore the original graph by removing all nodes and edges added in step \ref{itm:step-merging-source-dest}
			\end{enumerate}
			The last step ensures that subsequent routing queries are answered based on the original graph and not on an altered version of it.
			It also prevents an uncontrolled growth of the graph.
	
\section{Data structures}
	
	Before the separate steps of the graph generation are described in detail, the newly created data structures are presented.
		
	\subsection{Shadow areas}
	\label{subsec:shadow-areas}
		
		Shadow areas are a method I designed and implemented to quickly determine and filter out vertices that are not visible to each other.
		A well-suited analogy for shadow areas is a light bulb casting shadows, where anything within a shadow is not visible from the light bulb.
		Interpreting a vertex $v$ as a light bulb illuminating its surroundings, an obstacle $o$ casts a shadow outwards and every vertex within this shadow is definitely not visible from $v$.
		
		Each shadow is determined by three values: two values for the angular range (also referred to as \emph{angle area}) and a third value for the minimum distance from which other vertices within the angular range are definitely not visible.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\angle{20}
					\def\boundingVertexDistance{3}
					
					\tikzDot[label=$v$]{(0,1.5)}{v}
					\coordinate (shadow-arc-top)				at ($(v) +( \angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-bottom)				at ($(v) +(-\angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-top-end)			at ($(v) +( \angle:5.75)$);
					\coordinate (shadow-arc-bottom-end)			at ($(v) +(-\angle:5.75)$);
					\coordinate (shadow-arc-top-faded-end)		at ($(v) +( \angle:6.5)$);
					\coordinate (shadow-arc-bottom-faded-end)	at ($(v) +(-\angle:6.5)$);
					
					% Gray area
					\filldraw[lightgray] 
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					cycle;
					\draw[gray]
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end);
					
					\draw[dotted] (v) -- (shadow-arc-top);
					\draw[dotted] (v) -- (shadow-arc-bottom);
					
					% Faded gray area
					\filldraw[draw=none,lightgray,path fading=east]
					(shadow-arc-top-faded-end) --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom-faded-end) --
					cycle;
					\draw[gray,path fading=east] (shadow-arc-top-end) -- (shadow-arc-top-faded-end);
					\draw[gray,path fading=east] (shadow-arc-bottom-end) -- (shadow-arc-bottom-faded-end);
					
					% Obstacle
					\tikzDot[red]{(shadow-arc-top)}{o0}
					\tikzDot{(3.8,2)}{o1}
					\tikzDot[red]{($(v) +(-\angle:1.2)$)}{o2}
					\node[above right = 0.5 and 1.15 of o2] {$o$};
					
					% v' and v''
					\tikzDot[label=right:$v'$]{(2.1,1.1)}{v'}
					\tikzDot[label=right:$v''$]{(3.4,1.3)}{v''}
					
					\node[darkgray] at (4.7,1.5) {\huge$S$};
					
					\draw (o0) -- (o1) -- (o2) -- (o0);
				\end{tikzpicture}
			\end{figcenter}
			\caption{Shadow area $S$ cast by obstacle $o$ seen from vertex $v$. The two red vertices of obstacle $o$ are the bounding vertices determining angular range and distance of $S$. The vertex $v''$ is not visible from $v$ since it lies inside the shadow area. Note that $v'$ is not visible either even though it is not inside the shadow area.}
			\label{fig:shadow-area}
		\end{figure}
		
		The angular range is determined by two vertices, the so-called \emph{bounding vertices}, which are marked in red in \Cref{fig:shadow-area}, one with the smallest and one with the largest angle from the processed vertex $v$.
		Thus, the shadow area covers the largest possible angular range for the obstacle it belongs to.
		
		The larger distance of the two bounding vertices is the overall distance of the shadow area.
		Choosing the distance to the nearest bounding vertex would result in a shadow area leading to false positive results, meaning the checked vertex is within the shadow even though it is visible from $v$.
		Taking the larger distance into account results in false negative results (as $v'$ in \Cref{fig:shadow-area}), meaning the vertex is not in the shadow area of an obstacle even though it is hidden by it.
		These false negative results can be handled by a full visibility check.
		More importantly, when using the distance to the furthest bounding vertex, positive results, meaning the checked vertex is within a shadow area, are always true positive results and need no further checking.
		
		Creating the shadow area of an obstacle has a complexity that is linear in the amount of vertices of the obstacle and requires just a few arithmetic operations.
		
		
		Each shadow is an interval (between 0 and 360) of certain distance, which turns the visibility problem into an interval intersection problem.
		Thus, checking whether a certain coordinate is within any shadow area is a simple operation using just a few numeric comparisons.
		
		Keeping track of these shadow areas for each vertex significantly improves performance, especially with the use of the \texttt{BinIndex} data structure described \hyperref[subsec:binindex]{below}.
		Enabling the shadow area optimization and importing the 0.5km\textsuperscript{2} \enquote{OSM city} dataset (details are given in \Cref{subsubsec:eval-datasets}) with 7096 input vertices required 9.8s on average.
		Without the shadow area optimization this time increased by a factor of 10.62 to 104.2s.

	\subsection{BinIndex data structure}
	\label{subsec:binindex}
	
		The \texttt{BinIndex} class implements a linear bin-based index structure to store and access intervals.
		It consists of an array of $n$ many bins, each bin covering a certain interval.
		Items are added to all bins intersecting with the range of the item, therefore each bin is a linked list to potentially store multiple items.
	
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\l{0.5}
					\def\countX{9} % One more is added due to start at x=0
					\def\countY{1} % One more is added due to start at x=0
					
					\def\itemBStartX{1.6}
					\def\itemBIndexStart{1}
					\def\itemBLength{4.1}
					
					\def\itemAStartX{4}
					\def\itemAIndexStart{4}
					\def\itemALength{7.8}
					
					% Item A: Bins 1-5
					\draw[dotted,gray] (\itemBStartX*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\draw[dotted,gray] (\itemBStartX*\l+\itemBLength*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\filldraw[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBStartX*\l,\countY+4*\l) rectangle node[above right=0.125 and -1.3]{Item B: \itemBStartX\ - 5.7} ++(\itemBLength*\l,0.5*\l);
					
					% Item B: Bins 4-11(2)
					\draw[dotted,gray] (\itemAStartX*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\draw[dotted,gray] (\itemAStartX*\l+\itemALength*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\filldraw[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAStartX*\l,\countY+3*\l) rectangle node[above right=0.125 and -0.5]{Item A: \itemAStartX\ - 10.8} ++(\itemALength*\l,0.5*\l);
					
					\draw[->] (\itemAStartX*\l+1.85,\countY+2.75*\l) -- node[right] {1.} +(0,-1.5*\l);
					\draw[->] (\itemBStartX*\l+0.5,\countY+3.75*\l) -- node[right] {2.} +(0,-2.5*\l);
					
					% Draw pattern to bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+1*\l,0) rectangle ++(2*\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAIndexStart*\l,0) rectangle ++(6*\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (0,0) rectangle ++(2*\l,\l);
					
					% Draw gray versions of filled bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=lightgray] (\l*\countX+\l+\itemBIndexStart*\l+1*\l,0) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=lightgray] (\l*\countX+\l,0) rectangle ++(2*\l,\l);
					
					% Draw outlines of repeating gray bins
					\foreach \x in {0,...,2}
					{
						\draw[lightgray] (\l*\countX+\l+\l*\x,0) rectangle ++(\l,\l);
						\node[lightgray] at (\l*\countX+\l+\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					% Draw outlines of bins
					\foreach \x in {0,...,\countX}
					{
						\draw (\l*\x,0) rectangle ++(\l,\l);
						\node at (\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					\draw (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+0.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+3.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+4.5*\l,\l) -- ++(0,0.5*\l);
					
					\node at (0.5*\countX*\l,-0.875) {bins};
					\node[align=right] at (-1.25,0.5*\countY*\l+0.5*\l) {Linked lists\\of bins};
				\end{tikzpicture}
			\end{figcenter}
			\caption{Bin index filled with two items A (added first) and B (added last). Since item A was added first, B's entries in, which fall into a bin where en entry for item A already exists, are moved to a next item in the linked list of the bin. Each bin covers a range, which means non integer value are rounded down (for from-values) or up (for to-values).}
			\label{fig:bin-index}
		\end{figure}
		
		Point queries can be answered in $\bigo{1}$ and range queries in $\bigo{n}$ for $n$ items in the index.
		However, the range query functionality was not implemented as it is not needed for this work.
		\Cref{fig:bin-index} illustrates this data structure with a simple example.
		
		The NetTopologySuite offers several indices specifically made for intervals, namely the \texttt{Bintree}, \texttt{SIRtree} and \texttt{SortedPackedIntervalRTree}, of which only the first one is dynamic and thus allows insertions and deletions after the first query was made.
		This dynamic behavior is crucial for the use of shadow areas because the creation and handling happens in an online fashion while processing each vertex and its adjacent obstacles.
		
		\begin{wraptable}[9]{r}{8.5cm}
			\vspace{-1.35\baselineskip}
			\begin{tabularx}{\linewidth}{rRRRR}
\toprule
				& \multicolumn{2}{c}{\textbf{\texttt{BinIndex}}}	& \multicolumn{2}{c}{\textbf{\texttt{Bintree}}}	\\
\cmidrule(lr){2-3}\cmidrule(lr){4-5}
\textbf{Items}	& \textbf{Insert}	& \textbf{Query}				& \textbf{Insert}	& \textbf{Query}			\\
\midrule
1,000			& 0.003s			&  0.018ms						&   0.22ms			& 0,04s						\\
100,000			& 0.89s				&  0.7ms						&  21.6ms			& 135s						\\
200,000			& 2.14s				&  1.69ms						&  60.6ms			& 597s						\\
\bottomrule
			\end{tabularx}
			\caption{Comparison of \texttt{BinIndex} and \texttt{Bintree} on random intervals with one query per interval.}
			\label{table:interval-data-structures}
		\end{wraptable}
		
		Even though tree-based structures offer logarithmic query time complexities, the simple and list-based \texttt{BinIndex} with constant-time point queries is significantly faster, especially for larger datasets with hundreds of thousands of vertices.
		\Cref{table:interval-data-structures} compares the \texttt{BinIndex} with the \texttt{Bintree} showing the significant performance difference between these two data structures.
		Despite the advantages of a tree, the list-based \texttt{BinIndex} is multiple orders of magnitude faster than the \texttt{Bintree}.
		
\section{Routing graph creation}
\label{sec:visibility-graph-creation}
		
	This section presents implementation details on the steps given in \Cref{subsubsec:graph-generation} for graph generation, which includes generating a visibility graph and merging it with a road network.

	\subsection{Step 1: Obstacle filtering and feature preprocessing}
	\label{subsec:step-1-preprocessing}
			
		The first step is to filter all input features by their attributes to get all relevant obstacle features, regardless of their geometry.
		
		For performance reasons, multi-geometries, like \texttt{MultiPolygon} are split up into their separate geometries.
		% TODO Add remarks on handling islands in multi-polygons (s. ticket).
		%Holes in a polygon are not reachable in the first place and unwrapping the \texttt{MultiPolygon} will not change this.
		Unwrapping \texttt{MultiLineString} geometries is unproblematic as well, since the result are just multiple normal linestrings.
		Features made of \texttt{Point} geometries are also considered so that visibility edges can reach \term*{points of interest}.
		Visibility checks, which are performed in the next step of the algorithm, can ignore point features, since they have no spatial size.
		
		Another task within this first step is the triangulation of all polygonal shapes, which happens during the unwrapping of multi geometries.
		The main reason is a better performance for intersection checks, which is an important operation when checking if an obstacle is between two vertices.
		Details on the intersection check implementation are given \hyperref[subsubsec:intersection-checks]{below}.
		
		Also worth mentioning is the determination of each obstacles' convex hull.
		Of course this is not a complex task, since all obstacles are either triangles (due to the triangulation), linestrings or points.
		As described \hyperref[subsubsec:convex-hull]{below}, only vertices on the convex hull of obstacles will be considered in the further processing, which is a simple performance enhancement.
			
	\subsection{Step 2: Determining $k$ nearest visible neighbors}
	\label{subsec:step-2-knn-search}
			
		This step performs the main task of the visibility graph creation, namely the determination of all $k$ many visible neighbors for each vertex.
%		Determining not only $k$ but all visible neighbors would also be possible, but the parameter $k$ is an easy way to increase performance with the downside of not having all possible edges in the final routing graph.
%		The fact of potential suboptimal routes is discussed in the following.
		Before the actual algorithm is presented, some concepts and optimizations are described to understand the implemented algorithm.
		Then an overview of the performed steps is given followed by details on each of these steps.
		
		\subsubsection{Terminology}
		
			Before describing the details on determining the $k$ nearest neighbors, there are some terms that need to be defined.
			
			\begin{description}
				\item[obstacle] An \term{obstacle} is a geometry that should be avoided when determining shortest paths. It can be any type of geometry, not only a polygon.
				\item[visibility neighbor] A \term{visibility neighbor} (sometimes also \emph{visible neighbor}) of a vertex $v$ is another vertex $u$, which is visible to $v$ and vice versa. In other words an imaginary linestring from $v$ to $u$ does not intersect with any obstacle.
				\item[obstacle neighbor] An \term{obstacle neighbor} of a vertex $v$ is another vertex $u$ with the property that an (undirected) edge $\{v, u\}$ exists on that obstacle. In other words, $u$ is visible from $v$ but not via a visibility edge but instead via an edge of that obstacle.
				\item[valid angle area] A \term{valid angle area} describes a specially determined angular range around a vertex in which potential visibility neighbors are checked.
			\end{description}
		
		\subsubsection{Parameter $k$ and consequences on the shortest paths}
		
			The $k$, however, is not just a single parameter, but rather a tuple of two separate values:
			The number of bins $k_b$ and the number of maximum neighbors per bin $k_n$.
			This means a maximum of $k_b \cdot k_n$ many neighbors are considered.
			
			Each bin covers a certain angle area of the currently processed vertex, for example for a bin count of 36, each bin would cover a 10° area.
			In fact, the chosen default values of 36 bins with ten neighbors per bin worked well in all and usages of the implementation.
			When a bin is full and a new edge should be inserted, an existing edge might be removed from the bin.
			The criterion on which edge to remove is its length such that only the $k_n$ shortest edges per angle area of the bin remain.
			Since shortest paths are wanted, storing the $k_n$ longest edges would result paths that are too long.
			
			Without this subdivision into bins and by only considering a static maximum number of neighbors, i.e. with $k$ being a single value, it is possible to only have edges to complex and close objects but no edges to obstacles further away.
			In other words, the edges would not be distributed evenly around a vertex.
			
			An example for this would be a building next to a large and open park.
			The $n$ nearest neighbors of the house are probably quite close, for example vertices of other houses, hedges or fences.
			This means that the far away other side of the park is not withing the set of neighbors, even though the other side of the park is clearly visible.
			Subdividing the neighbors into bins ensures that there will definitely be connections to the other side of the park.
			
			Generally restricting the number of neighbors and therefore reducing the number of edges leads to less accurate routing results, i.e. to suboptimal paths, which are not shortest.
			As mentioned above, one bin only contains the $k_n$ shortest edges to its neighbors.
			The significance of the negative impact due to this restriction, however, is debatable.
			In the case of using the above mentioned default values of ten edges per 10° range, an omitted edge led to a similar direction as at least nine other edges did.
			The negative influence of a detour to the total route length by using the next best edge towards the destination is most likely not significant.
			
			However, the performance increase is not as large as with some of the other optimizations.
			Importing the 0.5km\textsuperscript{2} \enquote{OSM city} dataset (see \Cref{subsubsec:eval-datasets} for details) without the nearest neighbor filtering only took 9.3\% longer.
			
		\subsubsection{Convex hull}
		\label{subsubsec:convex-hull}
			
			As mentioned in \hyperref[subsec:step-1-preprocessing]{step 1}, only visibility neighbors for vertices lying on the convex hull of any obstacle are determined.
			The visibility neighbors themselves also have to be on any convex hull, which means vertices not being on any convex hull will never be connected to other vertices.
			This filtering strategy is a simple performance enhancement with some implications on the route quality as discussed below.
			
			The reason for this filtering is quite simple:
			Vertices not being on a convex hull will never be part of a shortest path.
			This is the case, since the convex hull itself is by definition the smallest set of points that creates an areas, which in turn contains all other points of the geometry\cite[2]{de-berg-computational-geometry}.
			Interpreting the convex hull as one possible path around a shape, the triangle inequality implies that this path is in deed the shortest path around the shape.
			When determining shortest paths, the part of a route bending around an obstacle will therefore always be a subset of its convex hull.
			
			Of course, a routing query might start within a concave part of the obstacle or somewhere completely else.
			This case, however, is independent of the graph generation and belongs to answering routing queries, which is covered later in \Cref{sec:answering-queries}.
			
			Also, the weighting function for the routing queries might not determine shortest, but for example fastest routes.
			In such case, the above filtering might result in inaccurate and suboptimal paths.
			Since this is just a performance enhancement and therefore an optional step, deactivating this filtering increases preprocessing time but solves this inaccuracy problem.
						
		\subsubsection{Valid angle areas}
			
			As mentioned above, a subsection of a shortest path bending around an obstacle always follows a part of the obstacle's convex hull.
			Eventually the path switches from following the convex hull to following a visibility edge, which leads to another obstacle and therefore another convex hull part.
			
			This means, a shortest path consists of many convex hull parts that are either connected by straight lines or touching each other.
			Connecting lines, i.e. line segments connecting two convex hull parts, are the shortest connections between the two convex hull parts on that shortest path.
			In other word, they cannot be relaxed to an alternative edge, which is shorter.
			
			Assuming a shortest path, which contains a convex hull edge $e_h=(u, v)$ followed by a connecting line edge $e_c=(v, w)$, then there is no relaxation possible to an edge $e_r=(u, w)$.
			According to the triangle inequality, such edge $e_r$ would be shorter than the two others, which means $d(e_r) < d(e_h) + d(e_c)$ would hold true.
			But since $e_h$ and $e_c$ are on the shortest path, no such $e_r$ can exist because then the shortest path would not have been shortest.
			This scenario is illustrated in \Cref{fig:convex-hull} with the convex hull segment $(v_0, v_1)$, the connecting line $(v_1, v_2)$ and the impossible relaxation $(v_0, v_2)$.
			
			In fact, edges, which can be relaxed as described, will \emph{never} be part of \emph{any} shortest path.
			If such an edge would be part of an shortest path, then the path is not shortest and would rather contain the relaxed edge.
			Determining these relaxable and therefore irrelevant edges is the key motivation of angular ranges, called \term[valid angle area]{valid angle areas}.
			Only visible vertices within any valid angle area are possible subsequent vertices in shortest paths.
			
			% TODO Numbering is weird
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\coordinate (c00) at (0,0.4);
						\draw (c00)
							-- ++(2.75,-0.2) coordinate (c01)
							-- ++(0.8,0.4) coordinate (c02)
							-- ++(0.1,0.8) coordinate (c03)
							-- ++(-2,0) coordinate (c04)
							-- ++(-1.4,-0.35) coordinate (c05)
							-- (c00);
						\node[above right = 0.15 and 1.6 of c00] {$o_1$};
						
						\coordinate (c10) at (2.5,3.85);
						\draw (c10)
							-- ++(-0.4,-0.4) coordinate (c11)
							-- ++(0.1,-0.6) coordinate (c12)
							-- ++(2.8,0) coordinate (c13)
							-- ++(-0.4,1.2) coordinate (c14)
							-- (c10);
						\node[below right = 0.25 and 0.75 of c10] {$o_2$};
						
						\def\d{1.5\pgflinewidth}
						\filldraw[thin,Green4!35!white] ($(c03)+(0,\d)$) -- +(180:0.35) arc [start angle=180, delta angle=-97.126, radius=0.35];
						\draw[thin,Green4] (c03) -- (intersection of c03--[shift=(c03)]82.874:3 and c12--c13);
						\draw[thin,Green4] ($(c03)+(0,\d)$) -- +(180:4);
						%							
						\filldraw[thin,DodgerBlue3!35!white] ($(c12)+(0,-\d)$) -- +(279.462:0.4) arc [start angle=279.462, delta angle=80.538, radius=0.4];
						\draw[thin,DodgerBlue3] (c12) -- (intersection of c12--[shift=(c12)]279.462:1 and c03--c04);
						\draw[thin,DodgerBlue3] ($(c12)+(0,-\d)$) -- +(0:4);
						
						\tikzDot[label={right:$s$}]{(c01)}{s}
						\tikzDot[label={right:$v_0$}]{(c02)}{v0}
						\tikzDot[label={right:$v_1$}]{(c03)}{v1}
						\tikzDot[label={left:$v_2$}]{(c12)}{v2}
						\tikzDot[label={below:$v_3$}]{(c13)}{v3}
						\tikzDot[label={above:$v_4$}]{(c04)}{v4}
						\tikzDot[label={left:$t$}]{(c10)}{t}
						
						\draw[->,Red2,thick] (s) -- (v0);
						\draw[->,Red2,thick] (v0) -- (v1);
						\draw[->,Red2,thick] (v1) -- (v2);
						\draw[->,Red2,thick] (v2) -- (c11);
						\draw[->,Red2,thick] (c11) -- (t);
					\end{tikzpicture}
				\end{figcenter}
				\caption{
					The path from $s$ via $v_1$ and $v_2$ to $t$ bends along the convex hulls of $o_1$ and $o_2$.
					The segment from $v_1$ to $v_2$ is a connecting line between the hull parts.
					% Suppose $v_2$ would be part of $o_1$, then the path from $s$ via $v_1$ to $v_2$ would be on its convex hull. Same holds true for $v_1$ and $o_2$ respectively.
					\\
					The angle area at $v_1$ marked in green indicates one of its valid angle areas.
					A visibility neighbors within this angle area can appear as a successor to $v_1$ in a shortest path.
					\\
					Vertex $v_3$, however, will never be a successor of $v_1$ on any shortest path.
				}
				\label{fig:convex-hull}
			\end{figure}
			
			These valid angle areas of a vertex $v$ are determined by its obstacle neighbors.
			For each pair of adjacent obstacle neighbors being at least $180^\circ$ apart from each other, two valid angle areas exist and are calculated as shown in the following example.
			Consider \Cref{fig:convex-hull} with the vertex $v_1$ and both obstacle neighbors $v_0$ and $v_4$.
			The area marked in green represents one of $v_1$'s valid angle areas determined by the two bearings $b(v_1, v_0)$ and $b(v_1, v_4)$ resulting in the angle interval $[b(v_1, v_4), b(v_1, v_0) - 180^\circ] = [270^\circ, 187.125^\circ - 180^\circ] = [270^\circ, 7.125^\circ]$.
			Subtracting $180^\circ$ of both bearings yields the second valid angle area of $[b(v_1, v_4) - 180^\circ, b(v_1, v_0)] = [90^\circ, 187.125^\circ]$.
			
			If one or no obstacle neighbor exists, then there is only one valid angle area covering $360^\circ$.
			No valid angle areas exist for obstacle neighbors being less than $180^\circ$ apart.
			A maximum of four valid abgle areas exist for the central vertex of three collinear vertices, in other words for one vertex with to obstacle neighbors being exactly $180^\circ$ apart.
			The valid angle areas in such case have a range of $0^\circ$ but are still used in the implementation to create edges for collinear neighbors.
			
			Since this is solely a performance optimization, the same considerations apply as in the above shown convex hull filtering.
			As soon as the weighting function is not creating a shortest path, this optimization might lead to suboptimal paths.
			Again, removing this optimization solves this problem.
			
		\subsubsection{Intersection checks}
		\label{subsubsec:intersection-checks}
			
			There are two types of intersection checks needed.
			One for line segment intersections and one to check whether or not a point lies within a triangle.
			Both intersection checks are performed using an own implementation instead of methods from the the NetTopologySuite.
			This has solely performance reasons since this specially tailored implementations are faster than the NTS methods.
			
			Performing ten million collision checks on random line segments with the custom implementation takes 195 ms on average, the fastes NTS method was the \texttt{RobustLineIntersector} and took 746 ms.
			Another method is the \texttt{LineSegment.Intersection} method, which took 1552 ms.
			
			Analoguously, performing one million random triangle intersection checks required 138 ms on average using the custom implementation and 174 ms using the fastest NTS method \texttt{Triangle.Intersects()}.
			Other method like \texttt{IPreparedGeometry.Intersects()} (406 ms), the \texttt{IndexedPointInAreaLocator} (707 ms) or the simple \texttt{Polygon.Intersects()} (2424 ms) were slower.
			
			The line segment intersection check uses an approach based on cross products as presented in \emph{Introduction to algorithms} by Thomas H Cormen et al.\cite[1018]{cormen-introduction-to-alg}.
			Due to the performance of this approach, it is used to check whether a line segment intersects with a whole obstacle by performing this intersection check for each segment of the obstacle.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\tikzDot[label={below left:$(1,0,0)$}]{(0,0)}{a}
						\tikzDot[label={below right:$(0,1,0)$}]{(4,0)}{b}
						\tikzDot[label={above:$(0,0,1)$}]{(2,3)}{c}
						
						\coordinate[between={a and c}] (ac);
						\coordinate[between={b and c}] (bc);
						\coordinate[between={a and b}] (ab);
						
						\draw (a) -- (b);
						\draw (a) -- (c);
						\draw (b) -- (c);
						
						\draw[dotted] (a) -- (bc);
						\draw[dotted] (b) -- (ac);
						\draw[dotted] (c) -- (ab);
						
						\tikzDot{(intersection of a--bc and b--ac)}{center};
						\node[below=1mm of center,inner sep=0mm,fill=white] {$c=(\nicefrac{1}{3},\nicefrac{1}{3},\nicefrac{1}{3})$};
						
						\tikzDot[label={left:$a=(0.5,0,0.5)$}]{(ac)}{left}
						\tikzDot[label={right:$b=(-0.2,0.5,0.7)$}]{(3.4,2.1)}{right}
					\end{tikzpicture}
				\end{figcenter}
				\caption{A triangle with barycentric coordinates and dotted lines for the three coordinate axes. Noteworthy is coordinate $b$ as it is outside the triangle, which can be directly seen from the negative value $-0.2$.}
				\label{fig:barycentric-triangle}
			\end{figure}
			
			Checking if a vertex lies inside a triangle is used for closed obstacles, which got triangulated during \hyperref[subsec:step-1-preprocessing]{preprocessing}.
			This method creates a barycentric coordinate system in which each coordinate has the form $(\lambda_1,\lambda_2,\lambda_3)$.
			For each corner of the triangle, exactly one value of the coordinate is one and the other two values are zero.
			\Cref{fig:barycentric-triangle} illustrates this with some exemplary points.
			Due to the properties of this coordinate system, a point $p$ is inside the triangle when the condition $0 < \lambda_i < 1$ is satisfied for all three values.
			
			Even though it sounds complex to create a whole coordinate system for a single collision check, this method only requires a few lines of code, uses only multiplications, additions and boolean operations and is therefore very fast.
			
		\subsubsection{Shadow area operations}
			
			The shadow areas are stored in the previously described \hyperref[subsec:binindex]{BinIndex} data structure.
			Inserting of the intervals therefore works as described in \Cref{subsec:binindex}.
			
			Shadow areas are always determined for a single vertex $v$.
			Checking if a different vertex $u$ is within any shadow area, and therefore not visible from $v$, is quite simple.
			First, all shadow areas are queried that fall into the bin of the $u$'s angle.
			Second, for each shadow area $s$ it is checked whether $u$ is at least a far away from $v$ as the minimum distance of $s$ and whether the vertex is exactly within the angle area of $s$.
			If both holds true for any such shadow area $s$, then $u$ is not visible from $v$.
		
		\subsubsection{Visibility graph generation overview}
		
			The performed steps of determining the visibility neighbors are the following.
			Each step is described with more details in the sections below.
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.},label={2.\arabic*.}]
				\item Determine the obstacle neighbors for each vertex.
				\item For each vertex $v$ lying on any convex hull, determine its visibility neighbors.
%				\begin{enumerate}
%					\item For each other vertex $u$, do the following:
%					\begin{enumerate}
%						\item Is $u$ in any shadow area \emph{or} not on any convex hull \emph{or} not in any valid angle area? If so: $u$ is not relevant, move to the next other vertex.
%						\item Query all obstacles between $v$ and $u$. This is done by the bounding box spanned by $v$ and $u$.
%						\item Create and store the shadow area of each such obstacle $o$.
%						\item Check if $u$ is a visibility neighbor, which is true if $u$ is a) still not in any shadow area and b) the line segment from $v$ to $u$ intersects with none of the above queries obstacles.
%					\end{enumerate}
%				\end{enumerate}
				\item Sort the visibility neighbors into bins based on the obstacle neighbors.
			\end{enumerate}
		
		\subsubsection{Step 2.1: Determining obstacle neighbors}
			
			Obstacle neighbors are needed to correctly handle the closed surface of obstacles, especially when two obstacles tough each other.
			This handling of neighbors is then used to form the valid angle areas, which in turn are used to determine whether a distant vertex is relevant for visibility checks.
			
			Determining the obstacle neighbors is relatively simple and straight forward.
			Each vertex $v$ of an obstacle $o$ is processed by looking at the previous and next vertices $v_p$ and $v_n$ on the same obstacle, which are both potential obstacle neighbors.
			If the line segment $(v, v_p)$, same applies to $v_n$, does not intersect with any other obstacle and is not an edge on any other obstacle, it is considered an obstacle neighbor.
			Latter case can be seen in \Cref{fig:obstacle-neighbors-touching} at the line segment $(v_1, v_3)$, which is part of two touching obstacles.
						
			\begin{figure}[h]
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot[label={[text=gray]below:$v_0$},gray]{(0,0)}{v0}
							\tikzDot[label=above:$v_1$]{(1,1.5)}{v1}
							\tikzDot[label=below:$v_2$]{(2,0)}{v2}
							\tikzDot[label=above:$v_3$]{(3,1.5)}{v3}
							\tikzDot[label={[text=gray]below:$v_4$},gray]{(4,0)}{v4}
							
							\draw[gray] (v0) -- (v1);
							\draw[->,very thick] (v2) -- (v1);
							\draw[->,very thick] (v2) -- (v3);
							\draw[gray] (v3) -- (v4);
						\end{tikzpicture}
					\end{figcenter}
					\caption{The black lines show the obstacle neighbors of $v_2$, which are $v_1$ and $v_3$.}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\def\d{1.5}
							
							\tikzDot[gray]{(0,0)}{c00}
							\tikzDot[label=above:$v_0$]{(0,\d)}{v0}
							\tikzDot[label=above:$v_1$]{(\d,\d)}{v1}
							\tikzDot[label=above:$v_2$]{(2*\d,\d)}{v2}
							\tikzDot[label={[text=gray]below:$v_3$},gray]{(\d,0)}{v3}
							\tikzDot[gray]{(2*\d,0)}{c20}
							
							\node at (0.5*\d,0.5*\d) {$o_1$};
							\node at (1.5*\d,0.5*\d) {$o_2$};
							
							\draw[gray] (c00) -- (v0);
							\draw[gray] (c00) -- (v3);
							\draw[->,very thick] (v1) -- (v0);
							\draw[->,very thick] (v1) -- (v2);
							\draw[->,gray] (v1) -- (v3);
							\draw[gray] (c20) -- (v3);
							\draw[gray] (c20) -- (v2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{The black lines show the obstacle neighbors of $v_1$, which are $v_0$ and $v_2$. The vertex $v_3$ is a neighbor as well, but hidden due to the touching obstacles $o_1$ and $o_2$ and therefore not an obstacle neighbor.}
					\label{fig:obstacle-neighbors-touching}
				\end{minipage}
			\end{figure}
			
			Because the step of determining the obstacle neighbors is very important for finding all relevant visibility neighbors, the implementation is within the \texttt{VisibilityGraphGenerator} class, namely the \texttt{AddObstacleNeighborsForObstacles} method.
			Each of the following steps is within this class as well, due to the close relationship.
			
		\subsubsection{Step 2.2: Determining visibility neighbors}
		
			As mentioned above, the \texttt{VisibilityGraphGenerator} class also contains the necessary methods to determine the visibility neighbors for every vertex.
			Essential to this process is the \texttt{GetVisibilityNeighborsForVertex} method determining the visibility neighbors for a single vertex.
			This method uses the concept of shadow areas stored in a BinIndex structure with a bin count of 360, each bin covering a 1° area.
%				Additionally, all obstacles casting a shadow are separately stored, simply to check whether or not a obstacle already casts a shadow.
%				Since querying of obstacles is necessary, they are stored in a QuadTree.
			
			The following steps are performed for every vertex $v$ being part of any convex hull.
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.},label={2.2.\arabic*.}]
				\item Continue with the next vertex if any of these conditions is true (otherwise process with the next step): Vertex $u$ is in a shadow area \emph{or} $u$ is outside a valid angle area \emph{or} $u$ is not part of any convex hull.
				\item Query all obstacles in the extent spanned by $v$ and $u$. For each obstacle $o$ the following steps are performed:
				\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.}-1em]
					\item Get or create the shadow area for $o$.
					\item If a new shadow area $S$ was just created \emph{and} $u \in S$, \emph{then} mark $u$ as hidden and skip all subsequent obstacles and continue with the next vertex.\label{itm:if-u-not-on-obstacle}
					\item At this point $u \not\in S$, so if $u$ is within the angular range of the obstacle as seen from $v$ \emph{and} there is an intersection of $o$ with the line segment $(v, u)$ (using the methods described above in \emph{\nameref{subsubsec:intersection-checks}}), \emph{then} mark $u$ as hidden.
				\end{enumerate}
				\item If $u$ has been marked as hidden, continue with the next vertex.
				\item If $u$ is visible, store it in the according bin for its angle and continue with the next vertex
			\end{enumerate}
			Having all visibility neighbors according to the amount and size of the bins, they are sorted in new bins based on the obstacle neighbors.
			This procedure is described in the following section and its result is stored for the graph creation, which is described below in \Cref{subsec:step-3-graph-creation}.
		
		\subsubsection{Step 2.3: Sort resulting visibility neighbors into bins}
		
			A naive approach to create a visibility graph would be to create edges between vertices that are visible to each other.
			This would make routing through line-based obstacles possible as \Cref{fig:routing-through-line-obstacle} illustrates.
			Such routing behavior is, of course, not desired.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\tikzDot{(2,0)}{vo0};
								\tikzDot[label={[label distance=-1.25mm]above right:$v $}]{(2,1)}{vo1};
								\tikzDot{(2,2)}{vo2};
								
								\draw (vo0) -- (vo1);
								\draw (vo1) -- (vo2);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo1);
								\draw[dotted] (vo1) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption{
							Visibility graph with naive connections.
							The two visibility edges at $v$ allow the shortest path to go through the obstacle from $n_a$ via $v$ to $n_b$.
						}
						\label{fig:routing-through-line-obstacle-a}
					\end{subfigure}
					\hfill
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\def\r{0.85mm}
								\def\rMargin{1.1mm} % = r + 0.25mm
								\def\gap{0.1875mm}
								
								\tikzDot{(2,0)}{vo0};
								\node (vo1) at (2,1) {};
								\node[label={[label distance=-1.25mm]above left:$v_a$}] at (vo1) {};
								\node[label={[label distance=-1.25mm]above right:$v_b$}] at (vo1) {};
								\coordinate (vo11) at ($(vo1)+(180:\rMargin)$);
								\coordinate (vo12) at ($(vo1)+(0:\rMargin)$);
								\tikzDot{(2,2)}{vo2};
								
								\filldraw (vo1)++(-\gap,0)++(90:\r) arc (90:270:\r);
								\filldraw (vo1)++( \gap,0)++(90:\r) arc (90:-90:\r);
								
%								\draw (vo1)++(270:\rMargin) -- (vo0);
								\draw ($(vo1)+(270:\r)+(-0.275mm,0)$) -- ($(vo0)+(-0.275mm,2mm)$) -- (vo0.north);
								\draw ($(vo1)+(270:\r)+( 0.275mm,0)$) -- ($(vo0)+( 0.275mm,2mm)$) -- (vo0.north);
%								\draw (vo1)++(90:\rMargin) -- (vo2);
								\draw ($(vo1)+(90:\r)+(-0.275mm,0)$) -- ($(vo2)+(-0.275mm,-2mm)$) -- (vo2.south);
								\draw ($(vo1)+(90:\r)+( 0.275mm,0)$) -- ($(vo2)+( 0.275mm,-2mm)$) -- (vo2.south);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo11);
								\draw[dotted] (vo12) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption{
							The visibility graph with connection respecting the obstacle. Vertex $v$ is split into two, $v_a$ and $v_b$, with exact same location. All gaps are for illustration purposes only.
							Vertex $v_a$ is connected to $n_a$ and $v_b$ to $n_b$ but $v_a$ and $v_b$ are not connected.
							This ensures that the shortest path from $n_a$ to $n_b$ does not lead through the middle vertex of the obstacle anymore.
						}
						\label{fig:routing-through-line-obstacle-b}
					\end{subfigure}
				\end{figcenter}
				\caption{
					Both illustrations show two of $v$'s visibility neighbors $n_a$ and $n_b$ next to a vertical obstacle. Routing through this obstacle should \emph{not} be possible.
					The dotted edges are visibility edges, the solid edges normal line segments of the obstacle.
				}
				\label{fig:routing-through-line-obstacle}
			\end{figure}
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\def\d{0.03}
						
						\tikzDot[label=below:$v$]{(0,0)}{v}
						
						\tikzDot[label=left:$n_1$]{(-2.25,0)}{n1}
						\tikzDot[label=above:$n_2$]{(0,2)}{n2}
						\tikzDot[label=right:$n_3$]{(2.25,0)}{n3}
						
						\draw[lightgray] (v) -- (n1);
						\draw[lightgray] (v) -- (n3);
						\draw[lightgray] (v) -- (n2);
						
						% Visibility edges to n1
						\tikzDot[DodgerBlue3]{(-1.1,-0.25)}{vn1}
						\tikzDot[DodgerBlue3]{(-1.6,-0.9)}{vn2}
						\tikzDot[DodgerBlue3]{(1.6,-0.5)}{vn3}
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn1);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn2);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn3);
%							\draw[DodgerBlue3,densely dashed,->] ($(v)+(-0.075,-\d)$) -- ($(n1)+(0.075,-\d)$);
%							\draw[DodgerBlue3,densely dashed,->] ($(v)+(0.075,-\d)$) -- ($(n3)+(-0.075,-\d)$);
						
						% Visibility edges to n3
						\tikzDot[Red2]{(0.7,1.4)}{vn4}
						\tikzDot[Red2]{(2,1)}{vn5}
						\draw[Red2,densely dotted,->] (v) -- (vn4);
						\draw[Red2,densely dotted,->] (v) -- (vn5);
%							\draw[Red2,densely dotted,->] ($(v)+(0.075,\d)$) -- ($(n3)+(-0.075,\d)$);
%							\draw[Red2,densely dotted,->] ($(v)+(\d,0.075)$) -- ($(n2)+(\d,-0.075)$);
						
						% Visibility edges to n2
						\tikzDot[Green4]{(-2,1.3)}{vn6}
						\draw[Green4,dashdotted,->] (v) -- (vn6);
%							\draw[Green4,dashdotted,->] ($(v)+(-\d,0.075)$) -- ($(n2)+(-\d,-0.075)$);
%							\draw[Green4,dashdotted,->] ($(v)+(-0.075,\d)$) -- ($(n1)+(0.075,\d)$);
					\end{tikzpicture}
				\end{figcenter}
				\caption{All visible neighbors of $v$ colored by their resulting bin. The neighbors $n_1$, $n_2$ and $n_3$ are also sorted into bins but they occur in each adjacent bin. The means $n_2$ is in the bin for area $n_1$/$n_2$ as well as in the bin for $n_2$/$n_3$.}
				\label{fig:visibility-bin-sorting}
			\end{figure}
			
			To correctly split and connect vertices, as illustrated for vertex $v$ in \Cref{fig:routing-through-line-obstacle}, it must be known which visibility neighbors are within the angular range of which adjacent obstacle neighbors.
			Knowing this enables the graph generation to sort all visibility neighbors into bins, as shown in \Cref{fig:visibility-bin-sorting}.
			Each of the resulting bins of a vertex $v$ covers the area between two adjacent obstacle neighbors.
			Later, in \hyperref[subsec:step-3-graph-creation]{step 3}, each bin leads to one new vertex.
			In the mentioned illustration, there would be two bins, one containing $n_a$ and one containing $n_b$, leading to two new vertices $v_a$ and $v_b$.
			
	\subsection{Step 3: Visibility graph creation}
	\label{subsec:step-3-graph-creation}
	
		The previous step created the raw data that is needed to generate a routable visibility graph, which is done in this third step.
		Since the \texttt{SpatialGraph} class in the NetTopologySuite uses the term \emph{node}, the term \emph{vertex} in this section refers to the vertices in the result of step 2, the term \emph{node} refers to the nodes in the output graph.
		
		As described at the end of the previous step, one node is created for each bin of neighboring vertices.
		Therefore, mappings between nodes, vertices and neighbor bins have to be created.
		For an example, consider \Cref{fig:routing-through-line-obstacle-b} where neighbor vertex $n_a$ should be connected to $v$.
		Since $v$ is split into two vertices, two nodes are created in the graph and therefore a mapping from node to bin is needed in order to connect the right nodes with each other.
		Two iterations over all vertices are used to first create the nodes with the respective bin-mapping and then, in the second iteration, this mapping is used to correctly connect all nodes.
		
		Without this mapping, it would not be clear to what node to connect.
		As the example in \Cref{fig:routing-through-line-obstacle} shows, without a mapping between visibility neighbor bins and nodes, it is unclear whether to connect $n_a$ to $v_a$ or to $v_b$ because they both are on the exact same location.
		
		The resulting spatial graph together with some of the mappings, which will be used to \hyperref[sec:answering-queries]{answer routing queries}, are stored in an instance of the \texttt{HybridVisibilityGraph} class.
		It contains the final spatial graph, as an instance of the \texttt{SpatialGraph} class provided by the MARS framework, along with all information needed to correctly add and connect new nodes.
		Adding nodes is only used for the start and destination locations of a routing query.
		
	\subsection{Step 4: Merging a road network into the visibility graph}
	\label{subsec:step-4-graph merging}
	
		To allow a routing algorithm to switch between the road network and visibility edges, the road network needs to be merged into the visibility graph.
		This happens not just by adding the road segments to the graph but by introducing and connecting new nodes at all intersections between road and visibility edges.
		\Cref{fig:merging-edges} illustrates this process for one road segment and two visibility edges.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\draw[<->,dashed] (v1n1) -- node[above right=0cm and 0.4cm] {$v$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above right=0cm and 0.4cm] {$u$} (v2n2);
							
							\draw[<->] (rn1) -- node[left] {$r$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{
						Before merging $r$ into the graph with a total of six nodes and six edges.
					}
					\label{fig:merging-edges-a}
				\end{subfigure}
				\hfill
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\tikzDot{(intersection of v1n1--v1n2 and rn1--rn2)}{i1}
							\tikzDot{(intersection of v2n1--v2n2 and rn1--rn2)}{i2}
							
							\draw[<->,dashed] (v1n1) -- node[above] {$v_1$} (i1);
							\draw[<->,dashed] (i1)   -- node[above] {$v_2$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above] {$u_1$} (i2);
							\draw[<->,dashed] (i2)   -- node[above] {$u_2$} (v2n2);
							
							\draw[<->] (rn1) -- node[right] {$r_1$} (i1);
							\draw[<->] (i1)  -- node[right] {$r_2$} (i2);
							\draw[<->] (i2)  -- node[right] {$r_3$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{
						After merging $r$. Two new vertices have been created and all edges are split on the intersection points. The graph size therefore increased by two nodes and eight edges (since all edges are bidirectional) to eight nodes and 14 edges.
					}
					\label{fig:merging-edges-b}
				\end{subfigure}
			\end{figcenter}
			\caption{
				Merging the road edge $r$ with two bidirectional visibility edges $v$ and $u$.
			}
			\label{fig:merging-edges}
		\end{figure}
	
		This final graph allows any routing algorithm to switch between road and visibility edges without further instructions or adjustments to the routing algorithm.
		

		With $E_R$ containing all road and $E_V$ all visibility edges, the complexity of the merge operation is within $\bigo{|E_R| \cdot |E_V|}$.
		This complexity arises from the fact that a road segment intersecting with $n$ visibility edges leads to $n+1$ new road segments, $n$ new intersection points and $n$ new visibility edges connecting them.
		In the worst case of a road segment intersecting with all visibility edges, $2 \cdot |E_V| + 1$ edges and $|E_V|$ nodes are added to the graph.
		Therefore, up to $|E_R| \cdot (2 \cdot |E_V| + 1)$ new edges and $|E_R| \cdot |E_V|$ new nodes are created.
		Even though it does not scale worse than linear in the input size $|E_R|$ of the road edges, the size of the output graph is significantly higher than the input road network, which are typically quite sparse networks.

		Measured graph sizes and effects on the routing performance are presented and discussed in \Cref{chap:evaluation}.
	
\section{Answering shortest path queries}
\label{sec:answering-queries}

	The process of answering shortest path queries, or routing queries in general, is directly implemented in the \texttt{HybridVisibilityGraph} class.
	Arbitrary weighting functions can be passed to customize the routing behavior.
	Implementing the core idea of determining routes between arbitrary location is, with the help of the above described techniques, rather simple:
	\begin{enumerate}
		\item \label{itm:answering-queries-add-nodes} Add nodes for the source and destination locations of the routing query to the graph.
		\item \label{itm:answering-queries-vis-edges} Determine visibility edges of each of the two nodes and merge these new edges into the graph.
		\item \label{itm:answering-queries-routing} Use a normal shortest path algorithm, such as A*, together with a weight function to find the path from the source to the destination.
		\item \label{itm:answering-queries-cleanup} Remove all previously added nodes and edges to get a clean graph for future routing requests.
	\end{enumerate}
	Step \ref{itm:answering-queries-add-nodes} creates two new nodes in the spatial graph as far as no node already exists at the respective location.
	
	Because step \ref{itm:answering-queries-vis-edges} is already implemented for the general graph generation, the core method \texttt{VisibilityGraphGenerator.GetVisibilityNeighborsForVertex()} can be reused without further adjustments.
	The most complex part is to determine the correct node to connect to.
	Thanks to the mappings of neighbor bins and their covered angle areas, as introduced in \Cref{subsec:step-3-graph-creation}, the correct bin for a location can be determined and a bidirectional edge be created.
	These are mostly simple filtering operations on the bins and can be implemented with very little code.
	
	Fortunately, the \texttt{SpatialGraph.RemoveNode(int)} method removes the node given by its ID and also removes all edges, which are connected to the given node.
	This makes step \ref{itm:answering-queries-cleanup} very easy since step \ref{itm:answering-queries-add-nodes} and \ref{itm:answering-queries-vis-edges} yield the IDs of created nodes, which are needed for the cleanup.
	
	The performance of routing and quality of the determined routes depend on several factors, with are discussed in the next chapter.
