% !TEX root = ../thesis.tex
% !TeX spellcheck = en_US

This section describes more implementation details of the previously described approach.
First, an overview of the algorithm with a short description of used frameworks and technologies is given.
After that, the main sections of this chapter show details of each algorithmic step.

\section{Algorithm overview}

	\subsection{Frameworks and technology}
	
		As mentioned in \cref{subsec:constrains} about the constrains, the used programming language is C\# due to the dependency to the MARS framework.
		The MARS framework is based on the widely used C\# library \term{NetTopologySuite} (\term*{NTS}), which contains numerous data structures, algorithms and helper function to handle and process geospatial data.
		
		The NTS was primarily used for basic data structures like features and geometries.
		Writing data to files is also done using NTS functions to serialize the geospatial data into GeoJSON files.
		
		The \term*{MARS} framework was also used for basic data structures, like the \texttt{Position} class.
		However, higher level structures like quadtrees and mathematical calculations were used as well.
		
		Not all data structures and algorithms already existed to create the hybrid routing graph.
		Most notably, a fast line intersection check was implemented as well as a bin based index structure.
		Several other helper functions and simpler structures, like a separate class for vertices, were added as well.

	\subsection{Early implementation based on the continuous dijkstra paradigm}
	
		An early implementation was not creating a visibility graph but instead it was based on the \term*{continuous dijkstra} paradigm with wavelets propagating through open spaces.
		However, there were two reasons why this first approach was replaced by a visibility graph based algorithm.
		
		The first reason was a bad performance.
		Early stages of the continuous dijsktra approach used a very naive and simple implementation without optimizations mentioned in recent literature on this topic.
		Before investing larger efforts into the implementation of a more complex approach, like the one presented by Hershberger and Suri\cite{hershberger-suri}, a simple preprocessing was introduced and lead to a major performance enhancement.
		This perprocessing determined the visibility between all vertices, which was later used to create events for the collision between wavelets and vertices.
		Such predetermined visibilities are the core of a visibility graph, thus moving to an actual visibility graph based approach was not a big step.
		
		The second reason to actually move towards a visibility graph was the difficulty and the disadvantages of combining the network based routing with the continuous dijkstra algorithm implemented so far, as described in \cref{sec:combining-routing-algorithms}.
		Therefore, the decision fell in favor of implementing and optimizing the creation of a routable visibility graph.
	
	\subsection{Chosen approach and potentially faster known algorithms}

		% Maybe this whole subsection is part of a later discussion?
		Due to the step by step development by turning the former continuous dijkstra preprocessing into a visibility graph generator, the implemented approach does not follow algorithms described in the literature.
		The performance of this implementation, as shown in \todo[inline]{link to evaluation chapter}, is still enough for practical use, but a well designed and fast algorithm, like the one presented by Overmars and Welzl \cite{overmars-weizl-visibility-graph} or the one by Ghosh and Mount \cite{ghosh-output-sensitive-vgraph}, would clearly increase performance.
		However, this performance enhancement would only affect the generation of a visibility graph and not the performance of the routing queries.
			
	\subsection{Algorithm steps}
		
		As describes in \cref{sec:components}, the \texttt{HybridVisibilityGraphGenerator} class provides a factory method to create a \texttt{HybridVisibilityGraph} from a given collection of features.
		This factory method consists of the following top level steps, which are all described in \cref{sec:visibility-graph-creation} in more detail:
		
		\begin{enumerate}
			\item Filter the given features for obstacles
			\item Determine the visibility neighbors
			\item Use this visibility relation to create a visibility graph
			\item Merge the existing road network into this graph
		\end{enumerate}
	
		The graph then allows to route between existing nodes.
		So far, routing queries between arbitrary locations cannot be answered, since this graph based approach only allows routing between existing nodes.
		To enable answering routing requests between arbitrary locations the resulting graph needs to be extended with edges from and to the given start and end locations.
		These edges are themselves visibility edges and can therefore be created just like the visibility edges before. The process is further described in \cref{sec:answering-queries} and contains the following steps:
		
		\begin{enumerate}
			\item Connect the source coordinate to the graph:
			\begin{enumerate}
				\item Add a node to the graph at the source coordinate
				\item Determine the visibility edges to and from the source coordinate
			\end{enumerate}
			\item Repeat the steps for the destination coordinate
			\item Route along the resulting graph
			\item Restore the original graph by removing all added nodes and edges
		\end{enumerate}
	
		The last step ensures that subsequent routing queries are answered based on the original graph and not on a previously altered version.
		It also prevents an uncontrolled growth of the graph.
		
\section{Visibility graph creation}
\label{sec:visibility-graph-creation}
		
	\subsection{Step 1: Obstacle filtering and feature preprocessing}
	\label{subsec:step-1-preprocessing}
			
			First the features are filtered to get all relevant obstacle features, which are of arbitrary shape.
			For performance reasons, multi-geometries, like \texttt{MultiPolygon} are split up into their separate geometries.
			This is not only unproblematic for \texttt{MultiLineString} but also for \texttt{MultiPolygon} features, since holes in a polygon are not reachable in the first place and unwrapping the \texttt{MultiPolygon} will not change this.
			% TODO Better formulation?
			Another task within this first step is the triangulation of all polygonal shapes.
			The main reason is a better performance for intersection checks, which is an important task of creating a visibility graph.
			
	\subsection{Step 2: Determining $k$ nearest visible neighbors}
			
			After having all preprocessed obstacles, the main task of the visibility graph creation is performed, namely determining all $k$ many visible neighbors.
			Determining all visible neighbors would also be possible, but this parameter is an easy way to increase performance with the downside of not having all possible edges in the final routing graph.
			
			\subsubsection{Terminology}
			
				Before describing the details on determining the $k$ nearest neighbors, there are some terms that need to be defined.
				
				\begin{description}
					\item[\term*{visibility neighbor}] Sometimes also just \emph{visible neighbor} is a vertex $u$ that is visible from the currently processed vertex $v$.
					\item[\term*{obstacle neighbor}] This is a vertex $u$ with an existing edge to or from the currently processed vertex $v$. In other words, $u$ is visible from $v$ but via an existing obstacle edge.
					\item[\term*{shadow area}] This is an angle area that starts at a certain distance, for example \enquote{10째 to 20째 with a minimum distance of 30 meter}.
				\end{description}
			
			\subsubsection{Algorithm overview}
			
				The performed steps of determining the visible neighbors are the following, more details are given in the section below.
				\begin{enumerate}
					\item Get the obstacle neighbors for each vertex.
					\item For each vertex $v$, determine its visibility neighbors as follows.
					\begin{enumerate}
						\item For each other vertex $u$, do the following:
						\begin{enumerate}
							\item Is $u$ in any shadow area? If so, which means $u$ is not visible, move to the next other vertex. Continue otherwise.
							\item Query all obstacles between $v$ and $u$.
							\item Create and store the shadow area of each such obstacle $o$.
							\item Mark $u$ as visibility neighbors if $u$ is still not in any shadow area and a line segment from $v$ to $u$ intersects with none of the above queries obstacles.
						\end{enumerate}
						\item Sort visibility neighbors into bins based on the obstacle neighbors.
					\end{enumerate}
				\end{enumerate}
			
			\subsubsection{Parameter $k$}
			
				The $k$, however, is not just a single parameter, but rather consists of two separate values:
				The number of bins and the number of maximum neighbors per bin.
				Each bin covers a certain angle area of each vertex, for example for a bin count of 36, each bin would cover a 10째 area.
				Without this subdivision of the neighbors, it is possible to only have edges to complex and close objects but no edges to obstacles further away.
				
				An example for this would be a large and open park where the $k$ nearest neighbors are probably all at the side of the park where the currently processed vertex is, even though the far away other side of the park is clearly visibly.
				This subdivision into bins ensure that there will definitely be connections to the other side of the park.
			
			\subsubsection{Determining obstacle neighbors}
				
				% TODO Revise this and maybe add more details
				Determining the obstacle neighbors is relatively simple and straight forward.
				Each coordinate $c$ of an obstacle $o$ is processed by looking at the previous and next coordinates $c_p$ and $c_n$ on that obstacle, which are the potential neighbors.
				If the line segment $(c, c_p)$ to the previous coordinate, for $c_n$ respectively, does not intersect with any obstacle, it is considered an obstacle neighbor.
				
				\begin{figure}[h]
					\begin{minipage}[t]{0.475\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\tikzDot[label={[text=gray]below:$v_0$},gray]{(0,0)}{v0}
								\tikzDot[label=above:$v_1$]{(1,1.5)}{v1}
								\tikzDot[label=below:$v_2$]{(2,0)}{v2}
								\tikzDot[label=above:$v_3$]{(3,1.5)}{v3}
								\tikzDot[label={[text=gray]below:$v_4$},gray]{(4,0)}{v4}
								
								\draw[gray] (v0) -- (v1);
								\draw[->] (v2) -- (v1);
								\draw[->] (v2) -- (v3);
								\draw[gray] (v3) -- (v4);
							\end{tikzpicture}
						\end{figcenter}
						\caption{The black lines show the obstacle neighbors of $v_2$, which are $v_1$ and $v_3$.}
					\end{minipage}
					\hfill
					\begin{minipage}[t]{0.475\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\def\d{1.5}
								
								\tikzDot[gray]{(0,0)}{c00}
								\tikzDot[label=above:$v_0$]{(0,\d)}{v0}
								\tikzDot[label=above:$v_1$]{(\d,\d)}{v1}
								\tikzDot[label=above:$v_2$]{(2*\d,\d)}{v2}
								\tikzDot[label={[text=gray]below:$v_3$},gray]{(\d,0)}{v3}
								\tikzDot[gray]{(2*\d,0)}{c20}
								
								\node at (0.5*\d,0.5*\d) {$o_1$};
								\node at (1.5*\d,0.5*\d) {$o_2$};
								
								\draw[gray] (c00) -- (v0);
								\draw[gray] (c00) -- (v3);
								\draw[->] (v1) -- (v0);
								\draw[->] (v1) -- (v2);
								\draw[->,gray] (v1) -- (v3);
								\draw[gray] (c20) -- (v3);
								\draw[gray] (c20) -- (v2);
							\end{tikzpicture}
						\end{figcenter}
						\caption{The black lines show the obstacle neighbors of $v_1$, which are $v_0$ and $v_2$. The vertex $v_3$ is a neighbor as well, but hidden due to the touching obstacles $o_1$ and $o_2$.}
					\end{minipage}
				\end{figure}
				
			\subsubsection{Shadow areas}
			
				Shadow areas are a simple method to quickly determine vertices that are definitely not visible to each other.
				The idea of shadow areas is the following:
				Let $v$ be the currently processed vertex and think of it as a light bulb illuminating its surroundings.
				An obstacle $o$ casts a shadow outwards and everything within this shadow is definitely not visible from $v$.
				
				The distance from which everything within the angle area of the shadow is definitely not visible from $v$, is determined by the two bounding vertices (marked in red in \cref{fig:shadow-area}).
				These bounding vertices determine the angular range and the furthest of these two determines the minimum distance of the shadow area.
				
				Keeping track of these shadow areas for each vertex significantly improves performance.
				\todo[inline]{conrete numbers?}\todo[inline]{Reference to BinIndex below or other used data structure (s. TODO below)}
				% NetworkRoutingPlayground->Jungfernstieg dataset with 7916 vertices: ~7.3s with and 67s without shadow areas -> speed up of factor ~9
				% Hamburg inner city dataset with 67819 vertices: 382s with and ~31000s without shadow areas -> speed up of factor ~81
				
				\begin{figure}[h]
					\begin{figcenter}
						\begin{tikzpicture}
							\def\angle{20}
							\def\boundingVertexDistance{3}
							
							\tikzDot[label=$v$]{(0,1.5)}{v}
							\coordinate (shadow-arc-top)				at ($(v) +( \angle:\boundingVertexDistance)$);
							\coordinate (shadow-arc-bottom)				at ($(v) +(-\angle:\boundingVertexDistance)$);
							\coordinate (shadow-arc-top-end)			at ($(v) +( \angle:5.75)$);
							\coordinate (shadow-arc-bottom-end)			at ($(v) +(-\angle:5.75)$);
							\coordinate (shadow-arc-top-faded-end)		at ($(v) +( \angle:6.5)$);
							\coordinate (shadow-arc-bottom-faded-end)	at ($(v) +(-\angle:6.5)$);
							
							% Gray area
							\filldraw[lightgray] 
								(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
								(shadow-arc-top-end) --
								(shadow-arc-bottom-end) --
								cycle;
							\draw[gray]
								(shadow-arc-bottom-end) --
								(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
								(shadow-arc-top-end);
							
							\draw[dotted] (v) -- (shadow-arc-top);
							\draw[dotted] (v) -- (shadow-arc-bottom);
							
							% Faded gray area
							\filldraw[draw=none,lightgray,path fading=east]
								(shadow-arc-top-faded-end) --
								(shadow-arc-top-end) --
								(shadow-arc-bottom-end) --
								(shadow-arc-bottom-faded-end) --
								cycle;
							\draw[gray,path fading=east] (shadow-arc-top-end) -- (shadow-arc-top-faded-end);
							\draw[gray,path fading=east] (shadow-arc-bottom-end) -- (shadow-arc-bottom-faded-end);
							
							% Obstacle 1
							\tikzDot[red]{(shadow-arc-top)}{o10}
							\tikzDot{(3.5,2)}{o11}
							\tikzDot[red]{($(v) +(-\angle:1.2)$)}{o12}
							\node[above right = 0.5 and 1 of o12] {$o_1$};
							
							% Obstacle 2
							\tikzDot[label=right:$v'$]{(3.5,1.35)}{o20}
							\tikzDot{(3.5,-0.25)}{o21}
							
							% Obstacle 3
							\tikzDot[label=right:$v''$]{(2.1,1.1)}{o30}
							\tikzDot{(2.1,-0.5)}{o31}
							
							\node[darkgray] at (4.65,1.5) {\huge$S$};
							
							\draw (o10) -- (o11) -- (o12) -- (o10);
							\draw (o20) -- node[right] {$o_2$} (o21);
							\draw (o30) -- node[left] {$o_3$} (o31);
						\end{tikzpicture}
					\end{figcenter}
					\caption{Shadow area $S$ cast by obstacle $o_1$ seen from vertex $v$. The vertex $v'$ of obstacle $o_2$ is not visible from $v$ since it lies inside the shadow area. The two red vertices of obstacle $o_1$ are the bounding vertices determining angle range and distance of $S$. Note that $v''$ is not visible from $v$ even though it is not inside the shadow area.}
					\label{fig:shadow-area}
				\end{figure}
				
			\subsubsection{BinIndex data structure}
			
				The \texttt{BinIndex} class implements a simple index structure to store and access intervals.
				It contains $n$ many bins of which each covers a certain range and consists of a linked list.
				When an item is added, it is added to each bin intersecting with the range of the item.
				Due to the linked list as the underlying data structure for the bins, queries can be answered in $\bigo{m}$ time for $m$ many items in the index.
				\Cref{fig:bin-index} illustrates this data structure with a simple example.
				
				\begin{figure}[h]
					\begin{figcenter}
						\begin{tikzpicture}
							\def\l{0.5}
							\def\countX{9} % One more is added due to start at x=0
							\def\countY{1} % One more is added due to start at x=0
							
							\def\itemBStartX{1.5}
							\def\itemBIndexStart{1}
							\def\itemBLength{4.2}
							
							\def\itemAStartX{4}
							\def\itemAIndexStart{4}
							\def\itemALength{7.8}
							
							% Item A: Bins 1-5
							\filldraw[pattern=north west lines,pattern color=red] (\itemBStartX*\l,\countY+4*\l) rectangle node[above right=0.125 and -0.5]{Item B: \itemBStartX\ - 5.7} ++(\itemBLength*\l,0.5*\l);
							
							% Item B: Bins 4-11(2)
							\filldraw[pattern=crosshatch dots,pattern color=blue] (\itemAStartX*\l,\countY+3*\l) rectangle node[above right=0.125 and -0.5]{Item A: \itemAStartX\ - 10.8} ++(\itemALength*\l,0.5*\l);
							
							\draw[->] (0.5*\countX*\l,\countY+2.25*\l) -- +(0,-1*\l);
							
							% Draw pattern to bins
							\fill[pattern=north west lines,pattern color=red] (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
							\fill[pattern=north west lines,pattern color=red] (\itemBIndexStart*\l+1*\l,0) rectangle ++(2*\l,\l);
							\fill[pattern=north west lines,pattern color=red] (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
							\fill[pattern=north west lines,pattern color=red] (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
							
							\fill[pattern=crosshatch dots,pattern color=blue] (\itemAIndexStart*\l,0) rectangle ++(6*\l,\l);
							\fill[pattern=crosshatch dots,pattern color=blue] (0,0) rectangle ++(2*\l,\l);
						
							% Draw outlines of bins
							\foreach \x in {0,...,\countX}
							{
								\draw (\l*\x,0) rectangle ++(\l,\l);
							}
							
							\draw (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
							\draw[->] (\itemBIndexStart*\l+0.5*\l,\l) -- ++(0,0.5*\l);
							
							\draw (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
							\draw[->] (\itemBIndexStart*\l+3.5*\l,\l) -- ++(0,0.5*\l);
							
							\draw (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
							\draw[->] (\itemBIndexStart*\l+4.5*\l,\l) -- ++(0,0.5*\l);
						
							% Label
							\foreach \x in {0,...,\countX}
							{
								\node at (\l*\x+0.5*\l,-0.35) {$\x$};
							}
						
							\node at (0.5*\countX*\l,-0.875) {bins};
							\node[align=right] at (-1.25,0.5*\countY*\l+\l) {Linked list\\of bins};
						\end{tikzpicture}
					\end{figcenter}
					\caption{Bin index filled with two items A and B. Since item A was added first, B's entries in, which fall into a bin where en entry for item A already exists, are moved to a next item in the linked list of the bin. Each bin covers a range, which means non integer value are rounded down (for from-values) or up (for to-values).}
					\label{fig:bin-index}
				\end{figure}
				
				The NetTopologySuite offers several indices specifically made for intervals, namely the \texttt{BinTree} and \texttt{SIRtree}, of which the latter one is static and does not allow insertions after the first query was made.
				Even though these two structures are tree based and theoretically offer a logarithmic query complexity compared to the linear complexity of the \texttt{BinIndex}, the simple and list based \texttt{BinIndex} is significantly faster even for larger datasets with tens of thousands of vertices.
				It is thinkable that the logarithmic complexity is useful for huge datasets with millions of vertices, but that has not been tested.
			
			\subsubsection{Intersection checks}
			\label{subsubsec:intersection-checks}
			
				All intersections are checked using own implementations no not rely on the generalized and therefore slower intersection checks of the NetTopologySuite.
				In fact, there are two types of intersection checks implemented:
				One check for intersection between two arbitrary line segments and one checks if a point lies within a triangle.
				This triangle check is used for closed obstacles, which got triangulated during \hyperref[subsec:step-1-preprocessing]{preprocessing}.
				
				The line segment intersection check uses a cross product based approach described in \emph{Introduction to algorithms} by Thomas H Cormen et al \cite[1018]{cormen-introduction-to-alg}.
				Even though this method only works on single line segments, it is significantly faster than general purpose checks provided by the NetTopologySuite.
				
				Checking if a  lies inside a triangle is done by a barycentric collision check.
				This method creates a barycentric coordinate system where each coordinate consists of three values $\lambda_1$, $\lambda_2$ and $\lambda_3$ for each corner vertex of the triangle.
				Due to the properties of this coordinate system, a point $p$ is inside the triangle when the condition $0 < \lambda_i < 1$ hold for each of the three values.
				Even though it sounds complex to create a whole coordinate system for a single collision check, this method only uses a few basic arithmetic operations and is therefore very fast.
				
			\subsubsection{Determining visibility neighbors}
			
				The \texttt{VisibilityGraphGenerator} class contains the above described method and structures to determine the visibility neighbors for every vertex.
				Essential to this process is the \texttt{GetVisibilityNeighborsForVertex} method determining the visibility neighbors for a single vertex.
				
				This method uses the concept of shadow areas stored in a BinIndex structure with a bin count of 360, each for a 1째 area.
				Additionally, all obstacles casting a shadow are stored, simply to not add shadows twice.
				
				For the given vertex $v$, each other vertices vertex $v'$ is checked for visibility by executing the following steps:
				
				\begin{enumerate}
					\item Check is $v'$ is in a shadow area and continue with the next vertex if this is the case.
					\item Determine the extent between $v$ and $v'$ and query all obstacles within this region. For each obstacle $o$ the following steps are performed:
					\begin{enumerate}
						\item Get the cached shadow area for $o$ of create a new shadow area if there is no cached one.
						\item If $v'$ is not part of $o$ and a new shadow area $S$ was just created, check if $v'$ is in $S$:
						\begin{enumerate}
							\item If so, mark $v'$ as hidden and skip all subsequent checks and obstacles.
							\item If not, perform an intersection check (with the methods described above in \emph{\nameref{subsubsec:intersection-checks}}) if $v'$ is within the angle area of the obstacle.
						\end{enumerate}
					\end{enumerate}
					\item If $v'$ has been marked as hidden, continue with the next vertex.
					\item If $V'$ is visible, store it in a bin for its angle and continue with the next vertex
				\end{enumerate}
			
				Having all visibility neighbors according to the amount and size of the bins, they are sorted in new bins based on the obstacle neighbors.
				This procedure is described in the following section and its result is stored for the graph creation, which is described below in \cref{subsec:step-3-graph-creation}.
			
			\subsubsection{Sort resulting visibility neighbors into bins}
			
				A naive approach to create a visibility graph would be to create edges between vertices that are visible to each other.
				This would make routing through line based obstacles possible as \cref{fig:routing-through-line-obstacle} illustrates.
				Such routing behavior is of course not correct.
				
				\begin{figure}[h]
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(2,0)}{vo0};
							\tikzDot[label={[label distance=-1mm]above right:$v$}]{(2,1)}{vo1};
							\tikzDot{(2,2)}{vo2};
							
							\draw (vo0) -- (vo1);
							\draw (vo1) -- (vo2);
							
							\tikzDot[label=left:$v_a$,outer sep=0.5mm]{(0.5,1.3)}{v1};
							\tikzDot[label=right:$v_b$,outer sep=0.5mm]{(3.5,1)}{v2};
							
							\draw[dotted] (v1) -- (vo1);
							\draw[dotted] (vo1) -- (v2);
							
							\draw[dotted] (v1) -- (vo0);
							\draw[dotted] (v1) -- (vo2);
							\draw[dotted] (v2) -- (vo0);
							\draw[dotted] (v2) -- (vo2);
						\end{tikzpicture}
						\hspace{2cm}
						\begin{tikzpicture}
							\def\r{0.85mm}
							\def\rMargin{1.1mm} % = r + 0.25mm
							\def\gap{0.1875mm}
							
							\tikzDot{(2,0)}{vo0};
							\node[label={[label distance=-1.25mm]above right:$v$}] (vo1) at (2,1) {};
							\coordinate (vo11) at ($(vo1)+(180:\rMargin)$);
							\coordinate (vo12) at ($(vo1)+(0:\rMargin)$);
							\tikzDot{(2,2)}{vo2};
							
							\filldraw (vo1)++(-\gap,0)++(90:\r) arc (90:270:\r);
							\filldraw (vo1)++( \gap,0)++(90:\r) arc (90:-90:\r);
							
%							\draw (vo1)++(270:\rMargin) -- (vo0);
							\draw ($(vo1)+(270:\r)+(-0.275mm,0)$) -- ($(vo0)+(-0.275mm,2mm)$) -- (vo0.north);
							\draw ($(vo1)+(270:\r)+( 0.275mm,0)$) -- ($(vo0)+( 0.275mm,2mm)$) -- (vo0.north);
%							\draw (vo1)++(90:\rMargin) -- (vo2);
							\draw ($(vo1)+(90:\r)+(-0.275mm,0)$) -- ($(vo2)+(-0.275mm,-2mm)$) -- (vo2.south);
							\draw ($(vo1)+(90:\r)+( 0.275mm,0)$) -- ($(vo2)+( 0.275mm,-2mm)$) -- (vo2.south);
							
							\tikzDot[label=left:$v_a$,outer sep=0.5mm]{(0.5,1.3)}{v1};
							\tikzDot[label=right:$v_b$,outer sep=0.5mm]{(3.5,1)}{v2};
							
							\draw[dotted] (v1) -- (vo11);
							\draw[dotted] (vo12) -- (v2);
							
							\draw[dotted] (v1) -- (vo0);
							\draw[dotted] (v1) -- (vo2);
							\draw[dotted] (v2) -- (vo0);
							\draw[dotted] (v2) -- (vo2);
						\end{tikzpicture}
					\end{figcenter}
					\caption{
						Both illustrations show a vertical obstacle with vertex $v$ in the middle.
						The dotted edges are visibility edges added during graph generation.
						\\
						Left:
						Visibility graph with naive connections.
						The two dotted visibility edges $(v_a, v)$ and $(v, v_b)$ allow a routing through the obstacle from $v_a$ vis $v$ to $v_b$.
						\\
						Right:
						The visibility graph with connection respecting the obstacles. For vertex $v$ two nodes are created.
						All gabs are for illustrational purposes only, the two nodes for $v$ and the vertical edges have the exact locations.
						One of $v$'s nodes is connected to $v_a$, the other one to $v_b$.
						This ensures that the shortest path from $v_a$ to $v_b$ does not lead through $v$ anymore.
					}
					\label{fig:routing-through-line-obstacle}
				\end{figure}
				
				It must therefore be known which visibility relations are between which obstacle neighbors.
				Knowing this enables the graph generation to distinguish between all the edges and results in correct routing results.
				More on this in the \cref{subsec:step-3-graph-creation} below.
				
				Each of the resulting bins of a vertex $v$ covers the area between two adjacent obstacle neighbors.
				All visibility neighbors are sorted into these bins, which is a simple and easy process.
				
				\begin{figure}[h]
					\begin{figcenter}
						\begin{tikzpicture}
							\def\d{0.03}
							
							\tikzDot[label=below:$v$]{(0,0)}{v}
							
							\tikzDot[label=left:$n_1$]{(-2.25,0)}{n1}
							\tikzDot[label=right:$n_2$]{(2.25,0)}{n2}
							\tikzDot[label=above:$n_3$]{(0,2)}{n3}
							
							\draw[lightgray] (v) -- (n1);
							\draw[lightgray] (v) -- (n2);
							\draw[lightgray] (v) -- (n3);
							
							% Visibility edges to n1
							\tikzDot[blue]{(-1.1,-0.25)}{vn1}
							\tikzDot[blue]{(-1.6,-0.9)}{vn2}
							\tikzDot[blue]{(1.6,-0.5)}{vn3}
							\draw[blue,densely dashed,->] (v) -- (vn1);
							\draw[blue,densely dashed,->] (v) -- (vn2);
							\draw[blue,densely dashed,->] (v) -- (vn3);
%							\draw[blue,densely dashed,->] ($(v)+(-0.075,-\d)$) -- ($(n1)+(0.075,-\d)$);
%							\draw[blue,densely dashed,->] ($(v)+(0.075,-\d)$) -- ($(n2)+(-0.075,-\d)$);
							
							% Visibility edges to n2
							\tikzDot[red]{(0.7,1.4)}{vn4}
							\tikzDot[red]{(2,1)}{vn5}
							\draw[red,densely dotted,->] (v) -- (vn4);
							\draw[red,densely dotted,->] (v) -- (vn5);
%							\draw[red,densely dotted,->] ($(v)+(0.075,\d)$) -- ($(n2)+(-0.075,\d)$);
%							\draw[red,densely dotted,->] ($(v)+(\d,0.075)$) -- ($(n3)+(\d,-0.075)$);
							
							% Visibility edges to n3
							\tikzDot[Green]{(-2,1.3)}{vn6}
							\draw[Green,dashdotted,->] (v) -- (vn6);
%							\draw[Green,dashdotted,->] ($(v)+(-\d,0.075)$) -- ($(n3)+(-\d,-0.075)$);
%							\draw[Green,dashdotted,->] ($(v)+(-0.075,\d)$) -- ($(n1)+(0.075,\d)$);
						\end{tikzpicture}
					\end{figcenter}
					\caption{All visible neighbors of $v$ colored by their resulting bin. The neighbors $n_1$, $n_2$ and $n_3$ are also connected with two edges each, one for each adjacent bin.}
					\label{fig:visibility-bin-sorting}
				\end{figure}
			
	\subsection{Step 3: Graph creation with visibility edges}
	\label{subsec:step-3-graph-creation}
		
	\subsection{Step 4: Merging a road network into the visibility graph}

\section{Answering shortest path queries}
\label{sec:answering-queries}