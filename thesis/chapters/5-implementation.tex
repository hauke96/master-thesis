% !TeX root = ../thesis.tex
% !TeX spellcheck = en_US

This section covers details on the implementation of the previously described design.
First, an overview of the algorithm is given, including a short description of used frameworks and technologies.
Second, two new and important data structures are described in detail.
And third, each algorithmic step of the graph generation and query answering is described in the main sections of this chapter.

\section{Algorithm overview}

	This section presents further details on the code dependencies and gives a broad overview of the algorithm.

	\subsection{Frameworks and technology}
	\label{subsec:frameworks-technology}
	
		As mentioned in \Cref{subsec:constraints} regarding the constraints, the used programming language is C\# due to the dependency to the MARS framework.
		The \term*{MARS} framework is based on the widely used C\# library \term{NetTopologySuite} (\term*{NTS}), which contains numerous data structures and algorithms to work with geospatial data.
		No additional third-party libraries were used.
		
		Primarily, the NTS was used for basic data structures like coordinates, geometries and features but also for calculations, e.g. the calculation of distances.
		Serialization of data is also done with the help of the NTS, however, this was primarily used for testing and development purposes.
		The \term*{MARS} framework is also used, primarily for the \texttt{Position} class and high-level structures such as the \texttt{SpatialGraph} and \texttt{QuadTree} classes.
		
		Not all data structures and algorithms already existed that were required to create the hybrid routing algorithm.
		Most notably, a \hyperref[subsubsec:intersection-checks]{fast line intersection check}, a \hyperref[subsec:binindex]{bin-based interval index} and a fast \hyperref[subsec:shadow-areas]{vertex filtering method} were implemented, which are all presented with more details in this chapter.
			
	\subsection{Algorithm steps}
	\label{subsec:algorithm-steps}
	
		This section gives details on the main parts of the algorithm, namely the generation of the hybrid visibility graph and the answering of routing requests.
		
		\subsubsection{Graph generation}
		\label{subsubsec:graph-generation}
		
			The \texttt{HybridVisibilityGraphGenerator} class provides the central method to create an instance of the \texttt{HybridVisibilityGraph} class from a given collection of features.
			This method consists of the following top-level steps, which are all described in \Cref{sec:visibility-graph-creation} in more detail:
			\begin{enumerate}
				\item \hyperref[subsec:step-1-preprocessing]{Filter the given features for obstacles}
				\item \hyperref[subsec:step-2-knn-search]{Determine the visibility neighbors}
				\item \hyperref[subsec:step-3-graph-creation]{Use this visibility relation to create a routable visibility graph}
				\item \hyperref[subsec:step-4-graph merging]{Merge the existing road network into this graph}
			\end{enumerate}
			A fifth but simple and not necessarily relevant step adds attributes of all POIs to the corresponding nodes of the resulting hybrid visibility graph, which can then be used during routing.
		
		\subsubsection{Answering routing queries}
		
			To determine optimal paths between arbitrary locations, the resulting graph needs to be extended with edges from and to the given source and destination locations, because vertices on the graph might not represent these locations.
			The generated edges themselves are visibility edges and can therefore be created and merged just like the visibility edges during the graph generation before.
			Further details are given in \Cref{sec:answering-queries} describing the following steps:
			\begin{enumerate}
				\item Determining visibility edges for the source and destination coordinates
				\item Merging these edges into the graph such that they can be removed afterward
				\item Routing along the resulting graph with a graph-based routing algorithm such as A*
				\item Restoring the original graph by removing all vertices and edges added before
			\end{enumerate}
			The last step ensures that subsequent routing queries are answered based on the original graph and not on an altered version of it.
			It also prevents an uncontrolled growth of the graph.
	
\section{Data structures}
	
	Before the separate steps of the graph generation are described in detail, the newly created data structures are presented.
		
	\subsection{Shadow areas}
	\label{subsec:shadow-areas}
		
		Shadow areas are a method I designed and implemented to quickly determine and filter out vertices that are not visible to each other.
		A well-suited analogy for shadow areas is a light bulb and obstacles casting shadows.
		Anything within a shadow is not visible from the light bulb.
		Interpreting a vertex $v$ as a light bulb illuminating its surroundings, an obstacle $o$ casts a shadow outwards.
		The fundamental property of this idea is that every vertex within this shadow is definitely not visible from $v$.
		Each shadow is determined by three values:
		Two values for the angular range (also referred to as \emph{angle area}) and a third value for the minimum distance from which other vertices within the angular range are definitely not visible.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\angle{20}
					\def\boundingVertexDistance{3}
					
					\tikzDot[label=$v$]{(0,1.5)}{v}
					\coordinate (shadow-arc-top)				at ($(v) +( \angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-bottom)				at ($(v) +(-\angle:\boundingVertexDistance)$);
					\coordinate (shadow-arc-top-end)			at ($(v) +( \angle:5.75)$);
					\coordinate (shadow-arc-bottom-end)			at ($(v) +(-\angle:5.75)$);
					\coordinate (shadow-arc-top-faded-end)		at ($(v) +( \angle:6.5)$);
					\coordinate (shadow-arc-bottom-faded-end)	at ($(v) +(-\angle:6.5)$);
					
					% Gray area
					\filldraw[lightgray] 
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					cycle;
					\draw[gray]
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom) arc [start angle=-\angle, delta angle=2*\angle, radius=\boundingVertexDistance] --
					(shadow-arc-top-end);
					
					\draw[dotted] (v) -- (shadow-arc-top);
					\draw[dotted] (v) -- (shadow-arc-bottom);
					
					% Faded gray area
					\filldraw[draw=none,lightgray,path fading=east]
					(shadow-arc-top-faded-end) --
					(shadow-arc-top-end) --
					(shadow-arc-bottom-end) --
					(shadow-arc-bottom-faded-end) --
					cycle;
					\draw[gray,path fading=east] (shadow-arc-top-end) -- (shadow-arc-top-faded-end);
					\draw[gray,path fading=east] (shadow-arc-bottom-end) -- (shadow-arc-bottom-faded-end);
					
					% Obstacle
					\tikzDot[Red2]{(shadow-arc-top)}{o0}
					\tikzDot{(3.8,2)}{o1}
					\tikzDot[Red2]{($(v) +(-\angle:1.2)$)}{o2}
					\node[above right = 0.5 and 1.15 of o2] {$o$};
					
					% v' and v''
					\tikzDot[label=right:$v'$]{(2.1,1.1)}{v'}
					\tikzDot[label=right:$v''$]{(3.4,1.3)}{v''}
					
					\node[darkgray] at (4.7,1.5) {\huge$S$};
					
					\draw (o0) -- (o1) -- (o2) -- (o0);
				\end{tikzpicture}
			\end{figcenter}
			\caption[Illustration of a shadow area.]{Shadow area $S$ cast by obstacle $o$ seen from vertex $v$. The two red vertices of obstacle $o$ are the bounding vertices determining the angular range and distance of $S$. The vertex $v''$ is not visible from $v$ since it lies inside the shadow area. Note that $v'$ is not visible either, even though it is not inside the shadow area.}
			\label{fig:shadow-area}
		\end{figure}
		
		The angular range is determined by two vertices, the so-called \emph{bounding vertices}, which are marked in red in \Cref{fig:shadow-area}, one with the smallest and one with the largest angle from the processed vertex $v$.
		Thus, the shadow area covers the largest possible angular range for the obstacle it belongs to.
		
		The furthest of the two bounding vertices determines the minimum distance of the shadow area.
		Using the distance of the nearest bounding vertex would result in a shadow area leading to false positive results, meaning a vertex might be in the shadow even though it is visible from $v$.
		Taking the larger distance into account results in false negative results (e.g. $v'$ in \Cref{fig:shadow-area}), meaning the vertex is not in the shadow area of an obstacle even though it is hidden by it.
		These false negative results can be handled by a full visibility check.
		More importantly, when using the distance to the furthest bounding vertex, \emph{every} positive result, meaning the checked vertex is within a shadow area, is a true positive result and needs no further checking.
		
		When processing a vertex, creating the corresponding shadow area of an obstacle only required one iteration over its vertices.
		Each shadow is an interval (between 0° and 360°) of certain distance, which turns the visibility problem into an interval intersection problem.
		Thus, checking whether a specific coordinate is within any given shadow area is a simple operation using just a few numeric comparisons.
		
		Keeping track of these shadow areas for each vertex significantly improves performance, especially with the use of the \texttt{BinIndex} data structure described \hyperref[subsec:binindex]{below}.
		Enabling the shadow area optimization yielded a speedup factor of 10.62 for a 0.5 km\textsuperscript{2} real-world dataset as described in \Cref{subsubsec:eval-datasets}).

	\subsection{BinIndex for intervals}
	\label{subsec:binindex}
	
		The \texttt{BinIndex} class implements a linear bin-based index structure to store and access intervals.
		It consists of an array of $n$ many bins, each bin covering a certain interval.
		Items are added to all bins intersecting with the range of the item and linked lists are used to store multiple items per bin.
	
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\def\l{0.5}
					\def\countX{9} % One more is added due to start at x=0
					\def\countY{1} % One more is added due to start at x=0
					
					\def\itemBStartX{1.6}
					\def\itemBIndexStart{1}
					\def\itemBLength{4.1}
					
					\def\itemAStartX{4}
					\def\itemAIndexStart{4}
					\def\itemALength{7.8}
					
					% Item A: Bins 1-5
					\draw[dotted,gray] (\itemBStartX*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\draw[dotted,gray] (\itemBStartX*\l+\itemBLength*\l, \countY+4*\l) -- +(0, -\countY-4*\l);
					\filldraw[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBStartX*\l,\countY+4*\l) rectangle node[above right=0.125 and -1.3]{Item B: \itemBStartX\ - 5.7} ++(\itemBLength*\l,0.5*\l);
					
					% Item B: Bins 4-11(2)
					\draw[dotted,gray] (\itemAStartX*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\draw[dotted,gray] (\itemAStartX*\l+\itemALength*\l, \countY+3*\l) -- +(0, -\countY-3*\l);
					\filldraw[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAStartX*\l,\countY+3*\l) rectangle node[above right=0.125 and -0.5]{Item A: \itemAStartX\ - 10.8} ++(\itemALength*\l,0.5*\l);
					
					\draw[->] (\itemAStartX*\l+1.85,\countY+2.75*\l) -- node[right] {1.} +(0,-1.5*\l);
					\draw[->] (\itemBStartX*\l+0.5,\countY+3.75*\l) -- node[right] {2.} +(0,-2.5*\l);
					
					% Draw pattern to bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+1*\l,0) rectangle ++(2*\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=north west lines,pattern color=Red2] (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (\itemAIndexStart*\l,0) rectangle ++(6*\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=DodgerBlue3] (0,0) rectangle ++(2*\l,\l);
					
					% Draw gray versions of filled bins
					\fill[preaction={fill, white},pattern=north west lines,pattern color=lightgray] (\l*\countX+\l+\itemBIndexStart*\l+1*\l,0) rectangle ++(\l,\l);
					\fill[preaction={fill, white},pattern=crosshatch dots,pattern color=lightgray] (\l*\countX+\l,0) rectangle ++(2*\l,\l);
					
					% Draw outlines of repeating gray bins
					\foreach \x in {0,...,2}
					{
						\draw[lightgray] (\l*\countX+\l+\l*\x,0) rectangle ++(\l,\l);
						\node[lightgray] at (\l*\countX+\l+\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					% Draw outlines of bins
					\foreach \x in {0,...,\countX}
					{
						\draw (\l*\x,0) rectangle ++(\l,\l);
						\node at (\l*\x+0.5*\l,-0.35) {$\x$};
					}
					
					\draw (\itemBIndexStart*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+0.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+3*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+3.5*\l,\l) -- ++(0,0.5*\l);
					
					\draw (\itemBIndexStart*\l+4*\l,1.5*\l) rectangle ++(\l,\l);
					\draw[->] (\itemBIndexStart*\l+4.5*\l,\l) -- ++(0,0.5*\l);
					
					\node at (0.5*\countX*\l,-0.875) {bins};
					\node[align=right] at (-1.25,0.5*\countY*\l+0.5*\l) {Linked lists\\of bins};
				\end{tikzpicture}
			\end{figcenter}
			\caption[BinIndex example with two inserted items.]{Bin index filled with two items A (added first) and B (added last). Since item A was added first, B's entries, which fall into a bin where an entry for item A already exists, are moved to the next item in the linked list of the bin. Each bin covers a range, meaning non-integer values are rounded down (for from-values) or up (for to-values).}
			\label{fig:bin-index}
		\end{figure}
		
		Point queries can be answered in $\bigo{1}$ (array access and returning the list) and range queries in $\bigo{n}$ for $n$ items in the index.
		However, the range query functionality was not implemented as it is not needed for this work.
		\Cref{fig:bin-index} illustrates this data structure with two items added to the index.
		
		The NetTopologySuite offers several indices specifically made for intervals, namely the \texttt{Bintree}, \texttt{SIRtree} and \texttt{SortedPackedIntervalRTree}, of which only the first one is dynamic and thus allows insertions and deletions after the first query was made.
		This dynamic behavior is crucial for the use of shadow areas because the creation and handling happens in an online fashion by processing each vertex and its adjacent obstacles.
		
		\begin{wraptable}{r}{8.8cm}
			\vspace{-0.5\baselineskip}
			\begin{tabularx}{\linewidth}{rRRRR}
\toprule
				& \multicolumn{2}{c}{\textbf{\texttt{BinIndex}}}	& \multicolumn{2}{c}{\textbf{\texttt{Bintree}}}	\\
\cmidrule(lr){2-3}\cmidrule(lr){4-5}
\textbf{Items}	& \textbf{Insert}	& \textbf{Query}				& \textbf{Insert}	& \textbf{Query}			\\
\midrule
   10,000		& 0.05 s			&   0.32 ms						&   3.83 ms			&      1.75 s				\\
  100,000		& 0.91 s			&   2.65 ms						&  22.71 ms			&    164 s					\\
  200,000		& 1.95 s			&   4.27 ms						&  58.86 ms			&    635 s					\\
1,000,000		& 9.86 s			&  21.27 ms						&  89.11 ms			& 12,549 s					\\
\bottomrule
			\end{tabularx}
			\caption{Comparison of \texttt{BinIndex} and \texttt{Bintree} on random intervals with one query per interval.}
			\label{table:interval-data-structures}
		\end{wraptable}
		
		Tree-based structures offer already good logarithmic query times, but the simple and list-based \texttt{BinIndex} with constant-time complexity is significantly faster, especially for larger datasets with hundreds of thousands of vertices.
		\Cref{table:interval-data-structures} compares the \texttt{BinIndex} with the \texttt{Bintree}, showing the significant performance differences between these two data structures.
		The list-based \texttt{BinIndex} is multiple orders of magnitude faster than the \texttt{Bintree}.
		
\section{Routing graph creation}
\label{sec:visibility-graph-creation}
		
	This section presents implementation details on the steps given in \Cref{subsubsec:graph-generation} for graph generation, which includes generating a visibility graph and merging it with a road network.

	\subsection{Step 1: Obstacle filtering and feature preprocessing}
	\label{subsec:step-1-preprocessing}
			
		The first step is to filter all input features by their attributes to get all relevant obstacle features, regardless of their geometry.
		For performance reasons (during triangulation as described below), multi-geometries and polygons are split into their separate geometries.
		The NTS implementation of a polygon can have outer and inner rings, which are unwrapped into separate geometries.
		Unwrapping \texttt{MultiLineString} geometries is also unproblematic since the result is just a collection of ordinary linestrings.
		Features made of \texttt{Point} geometries are also considered so that visibility edges can reach \term*[point of interest]{points of interest} (\term[POI]{POIs}).
		
		The second task within this first step is the triangulation of all polygonal shapes, which happens during the unwrapping of multi-geometries.
		The main reason is a better performance for intersection checks, which is an important operation when checking if an obstacle is between two vertices.
		Details on the intersection check implementation are given \hyperref[subsubsec:intersection-checks]{below}.
		
		Also worth mentioning is the determination of each obstacles' convex hull, which is fortunately not a complex task for polygons.
		As described \hyperref[subsubsec:convex-hull]{below}, only vertices on the convex hull of obstacles will be considered in the further processing, which is a simple performance enhancement.
			
	\subsection{Step 2: Determining $k$ nearest visible neighbors}
	\label{subsec:step-2-knn-search}
			
		This step performs the main task of the visibility graph creation, namely for each vertex the determination of all visible \term*[k-nearest neighbors]{$k$ many nearest neighbors} (\term*{kNN}).
		Before the actual algorithm is presented, some concepts and optimizations are described to understand the implemented algorithm.
		Then an overview of the performed steps is given, followed by details on each step.
		
		\subsubsection{Terminology}
		
			Some terms need to be defined before describing the details of determining the $k$ nearest neighbors:
			\begin{description}
				\item[obstacle] An \term{obstacle} is a geometry that should be avoided when determining shortest paths. It can be any type of geometry, not only a polygon.
				\item[visibility neighbor] A \term{visibility neighbor} (sometimes also \emph{visible neighbor}) of a vertex $v$ is another vertex $u$ which is visible to $v$ and vice versa. In other words, an imaginary linestring from $v$ to $u$ does not intersect with any obstacle.
				\item[obstacle neighbor] Two vertices $v$ and $u$ are \term[obstacle neighbor]{obstacle neighbors} if they are part of the same obstacle and directly next to each other in its coordinate list.
				\item[valid angle area] A \term{valid angle area} describes a specially determined angular range around a vertex in which potential visibility neighbors are checked.
			\end{description}
		
		\subsubsection{Parameter $k$ and consequences on the shortest paths}
		
			As a performance enhancement providing an upper bound on the number of visibility neighbors, only $k$ many neighbors per vertex are determined.
			The parameter $k$ is not a single numeric parameter but rather a tuple of two separate values:
			The number of bins is $k_b$ and the number of maximum neighbors per bin is $k_n$, which means a maximum of $k_b \cdot k_n$ many neighbors are determined and considered.
			
			Each bin covers a certain angle area of the currently processed vertex, for example, for a bin count of 36, each bin would cover a 10° area.
			In fact, the chosen default values of 36 bins with ten neighbors per bin worked well in all and usages of the implementation.
			When a bin is full but a new vertex should be inserted, an existing vertex might be removed from the bin.
			The criterion on which vertex to remove is its distance such that only the $k_n$ nearest vertices of a bin remain.
			Since shortest paths are wanted, storing the $k_n$ furthest visibility neighbors might yield too long paths, unnecessary detours and maybe even very close but unconnected vertices.
			
			Without this subdivision into bins and by only considering a static maximum number of neighbors, i.e. with $k$ being a single numeric value, it is not endured that visibility neighbors are evenly distributed.
			Considering some complex buildings next to a large, open park illustrates this effect.
			The $k$ nearest neighbors of a vertex $v$ might all be part of these buildings and the other distant side of the park is not within the set of visibility neighbors, even though the other side of the park is unquestionably visible.
			Subdividing the neighbors into bins ensures that there will definitely be some connections to the other side of the park.
			
			Generally restricting the number of neighbors reduces the number of created edges and leads to less accurate routing results, i.e. to non-shortest paths.
			However, the negative impact due to this restriction is not considered significant for sufficient values of $k_b$ and $k_n$.
			From a theoretical perspective, using the above-mentioned default values of ten edges per 10° range, an omitted neighbor $u$ of a vertex $v$ was located in a similar direction as all other neighbors in this bin did.
			The additional distance of a detour from $v$ over some other vertices to $u$, due to the missing direct connection, is most likely relatively small.
			From a practical perspective, described in more detail in \Cref{subsubsec:eval-datasets}, no large detours were observed in any used dataset.
			Using a 0.5 km\textsuperscript{2} large real-world dataset, enabling this optimization with the described default values reduced the number of edges by 5.4\% and increased performance by 9.3\%.
			
		\subsubsection{Convex hull filtering}
		\label{subsubsec:convex-hull}
			
			In order to be connected to other vertices, a vertex must be part of a non-polygonal obstacle or the convex hull of a polygonal obstacle.
			A polygonal vertex (a vertex on a polygonal obstacle), which is not part of any convex hull, is not connected to other vertices.
			This filtering strategy is a simple performance enhancement with some implications on the route quality, as discussed below.
			
			The reason for this filtering is quite simple:
			Polygonal vertices not being on any convex hull will never be part of any shortest path.
			This is the case since the convex hull itself is by definition the smallest set of points that creates an area, which in turn contains all other points of the geometry\cite[2]{de-berg-computational-geometry}.
			Interpreting the convex hull as path, the triangle inequality implies that it is indeed the shortest path around the geometry.
			Therefore, when determining shortest paths through open spaces, the part of a path bending around an obstacle is a subset of its convex hull.
			
			Of course, a routing query might start within a concave part of an obstacle or somewhere completely else.
			This case, however, is independent of the graph generation and belongs to answering routing queries, which is covered later in \Cref{sec:answering-queries}.
			
			Also, the weighting function for the routing queries might not determine shortest, but for otherwise weighted routes.
			In such case, the above filtering might result in inaccurate and suboptimal paths due to missing edges.
			Since this is solely a performance enhancement and therefore optional, deactivating this filtering increases preprocessing time but solves this inaccuracy problem.
						
		\subsubsection{Valid angle areas}
		\label{subsubsec:valid-angle-areas}
			
			As mentioned above, a subsection of a shortest path bending around an obstacle always follows a part of the obstacle's convex hull.
			Eventually, the path switches from following the convex hull to following a visibility edge, which leads to another obstacle, meaning another convex hull part.
			
			This means, a shortest path consists of many convex hull parts that are either connected by straight lines or touch each other where the underlying obstacles touch.
			A connecting line, i.e. a line segment connecting two convex hull parts, is the shortest possible connection between the two convex hull parts.
			In other words, connecting lines cannot be relaxed to an alternative edge, which is shorter.
			
			Assuming a shortest path contains a convex hull edge $e_h=(u, v)$ followed by a connecting line edge $e_c=(v, w)$, then there is no relaxation possible to an edge $e_r=(u, w)$.
			According to the triangle inequality, the edge $e_r$ would be shorter than the two others, which means $d(e_r) < d(e_h) + d(e_c)$ would be true.
			But since $e_h$ and $e_c$ are on the shortest path, no such $e_r$ can exist because then the shortest path would not have been shortest.
			\Cref{fig:convex-hull} illustrates this scenario with the convex hull segment $(v_0, v_1)$, the connecting line $(v_1, v_2)$ and the impossible relaxation $(v_0, v_2)$.
			
			In fact, edges, which can be relaxed as described, will \emph{never} be part of \emph{any} shortest path.
			If such an edge would be part of a shortest path, then the path is not shortest and would rather contain the relaxed edge.
			Determining these relaxable and, therefore, irrelevant edges is the key motivation of angular ranges called \term[valid angle area]{valid angle areas}.
			Only visible neighbors of a vertex $v$ within its valid angle areas are possible subsequent vertices on shortest paths via $v$.
			In \Cref{fig:convex-hull}, the segment $(v_1, v_3)$ is not part of any shortest path from $s$ because it can be relaxed to $v_0, v_3$.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\coordinate (c00) at (0,0.4);
						\draw (c00)
							-- ++(2.75,-0.2) coordinate (c01)
							-- ++(0.8,0.4) coordinate (c02)
							-- ++(0.1,0.8) coordinate (c03)
							-- ++(-2,0) coordinate (c04)
							-- ++(-1.4,-0.35) coordinate (c05)
							-- (c00);
						\node[above right = 0.15 and 1.6 of c00] {$o_1$};
						
						\coordinate (c10) at (2.5,3.85);
						\draw (c10)
							-- ++(-0.4,-0.4) coordinate (c11)
							-- ++(0.1,-0.6) coordinate (c12)
							-- ++(2.8,0) coordinate (c13)
							-- ++(-0.4,1.2) coordinate (c14)
							-- (c10);
						\node[below right = 0.25 and 0.75 of c10] {$o_2$};
						
						\def\d{1.5\pgflinewidth}
						\filldraw[line width=0,Green4!35!white]
							($(c03)+(0,\d)$) --
							+(180:0.35) arc [start angle=180, delta angle=-97.126, radius=0.35];
						\draw[thin,Green4] (c03) -- (intersection of c03--[shift=(c03)]82.874:3 and c12--c13);
						\draw[thin,Green4] ($(c03)+(0,\d)$) -- +(180:4);
						
						\filldraw[line width=0,DodgerBlue3!35!white]
							($(c12)+(0,-\d)$) --
							+(279.462:0.4) arc [start angle=279.462, delta angle=80.538, radius=0.4];
						\draw[thin,DodgerBlue3] (c12) -- (intersection of c12--[shift=(c12)]279.462:1 and c03--c04);
						\draw[thin,DodgerBlue3] ($(c12)+(0,-\d)$) -- +(0:4);
						
						\tikzDot[label={right:$s$}]{(c01)}{s}
						\tikzDot[label={right:$v_0$}]{(c02)}{v0}
						\tikzDot[label={right:$v_1$}]{(c03)}{v1}
						\tikzDot[label={left:$v_2$}]{(c12)}{v2}
						\tikzDot[label={below:$v_3$}]{(c13)}{v3}
						\tikzDot[label={above:$v_4$}]{(c04)}{v4}
						\tikzDot[label={left:$t$}]{(c10)}{t}
						
						\draw[->,Red2,thick] (s) -- (v0);
						\draw[->,Red2,thick] (v0) -- (v1);
						\draw[->,Red2,thick] (v1) -- (v2);
						\draw[->,Red2,thick] (v2) -- (c11);
						\draw[->,Red2,thick] (c11) -- (t);
					\end{tikzpicture}
				\end{figcenter}
				\caption[Visualization of valid angle areas.]{
					The path from $s$ via $v_1$ and $v_2$ to $t$ bends along the convex hulls of $o_1$ and $o_2$.
					The segment from $v_1$ to $v_2$ is a connecting line between the hull parts.
					The angle area at $v_1$ (green) indicates one of its valid angle areas.
					A visibility neighbor within this angle area can appear as a successor to $v_1$ in a shortest path.
					Vertex $v_3$, however, is not part of any of $v_1's$ valid angle areas and will never be a successor of $v_1$ on any shortest path.
				}
				\label{fig:convex-hull}
			\end{figure}
			
			These valid angle areas of a vertex $v$ are determined by its obstacle neighbors.
			For each pair of adjacent obstacle neighbors being at least $180^\circ$ apart from each other, two valid angle areas $a_v^1$ and $a_v^2$ exist for vertex $v$ and its neighbors $u$ and $w$.
			The function $b: V \times V \rightarrow \mathbb{R}$ is called \term{bearing}, meaning the clockwise increasing angle from a vertex $v$ to $v'$ starting at 0° if $v'$ is directly above $v$.
			\begin{align*}
				a_v^1 &= [b(v, u), b(v, w) - 180^\circ] \\
				a_v^2 &= [b(v, u) - 180^\circ, b(v, w)]
			\end{align*}
			For example, for $v_1$ in \Cref{fig:convex-hull} with the obstacle neighbors $v_0$ and $v_4$ the angular range $[b(v_1, v_4), b(v_1, v_0) - 180^\circ] = [270^\circ, 187.125^\circ - 180^\circ] = [270^\circ, 7.125^\circ]$ is one valid angle area.
			Subtracting $180^\circ$ of both bearings yields the second one of $[90^\circ, 187.125^\circ]$.
			
			If one or no obstacle neighbor exists, only one valid angle area covering $360^\circ$ will be created.
			No valid angle areas exist for obstacle neighbors being less than $180^\circ$ apart.
			A maximum of four valid angle areas exist, each of $0^\circ$, for the central vertex of three collinear vertices, which has two obstacle neighbors being exactly $180^\circ$ apart.
			
			Analogous to the convex hull filtering, this is solely a performance enhancement and might lead to suboptimal results depending on weighting.
			Removing this optimization solves this problem.
			
		\subsubsection{Intersection checks}
		\label{subsubsec:intersection-checks}
			
			There are two types of intersection checks needed:
			One for line segment intersections and one to check whether or not a point lies within a triangle.
			Both intersection checks are performed using a custom implementation instead of methods from the NetTopologySuite.
			
			Using custom implementations has solely performance reasons:
			Performing ten million collision checks between random line segments took 195 ms on average with the custom implementation and 746 ms with the fastest NTS method \texttt{RobustLineIntersector.ComputeIntersection()}.
			Analogously, performing one million random triangle intersection checks required 138 ms on average using the custom implementation and 174 ms using the fastest NTS method \texttt{Triangle.Intersects()}.
			
			The line segment intersection check uses cross products as presented in \emph{Introduction to algorithms} by Cormen et al.\cite[1018]{cormen-introduction-to-alg}.
			Due to the performance of this approach, it is used to check whether a line segment intersects with a whole obstacle by performing this intersection check for each segment of the obstacle.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\tikzDot[label={below left:$(1,0,0)$}]{(0,0)}{a}
						\tikzDot[label={below right:$(0,1,0)$}]{(4,0)}{b}
						\tikzDot[label={above:$(0,0,1)$}]{(2,3)}{c}
						
						\coordinate[between={a and c}] (ac);
						\coordinate[between={b and c}] (bc);
						\coordinate[between={a and b}] (ab);
						
						\draw (a) -- (b);
						\draw (a) -- (c);
						\draw (b) -- (c);
						
						\draw[dotted] (a) -- (bc);
						\draw[dotted] (b) -- (ac);
						\draw[dotted] (c) -- (ab);
						
						\tikzDot{(intersection of a--bc and b--ac)}{center};
						\node[below=1mm of center,inner sep=0mm,fill=white] {$c=(\nicefrac{1}{3},\nicefrac{1}{3},\nicefrac{1}{3})$};
						
						\tikzDot[label={left:$a=(0.5,0,0.5)$}]{(ac)}{left}
						\tikzDot[label={right:$b=(-0.2,0.5,0.7)$}]{(3.4,2.1)}{right}
					\end{tikzpicture}
				\end{figcenter}
				\caption[Example of a barycentric coordinate system.]{A triangle with barycentric coordinates and dotted coordinate axes. Noteworthy is coordinate $b$ being outside the triangle, which can be directly seen from the negative value $-0.2$.}
				\label{fig:barycentric-triangle}
			\end{figure}
			
			Triangle intersection checks are used for closed obstacles, being triangulated during \hyperref[subsec:step-1-preprocessing]{preprocessing}.
			Coordinates in a barycentric coordinate system have the form $(\lambda_1,\lambda_2,\lambda_3)$ of which for each corner of the triangle exactly one value of the coordinate is set to one, and all other ones are zero.
			Due to the properties of barycentric coordinates, a point $p$ is inside the triangle when the condition $0 < \lambda_i < 1$ holds for all three values as illustrated in \Cref{fig:barycentric-triangle} with some exemplary points.
			
			It may sound complex to create a whole coordinate system for a single collision check, but this method only uses a few multiplications, additions and boolean operations and is therefore very fast.
			
		\subsubsection{Visibility checks using shadow area}
			
			Shadow areas are stored in the \hyperref[subsec:binindex]{BinIndex} and are always determined for a single vertex $v$.
			Checking the visibility to a different vertex $u$ is quite simple.
			Query all shadow areas for $u$'s bearing from v and check for each shadow area $s$ whether $u$ is further away than the minimum distance of $s$ and if $u$ is exactly within the angular range of $s$.
			If both conditions are satisfied for any shadow area $s$, then $u \in s$ and is therefore not visible from $v$.
			One visibility check has a runtime complexity of $\bigo{n}$ for $n$ shadow areas due to the $\bigo{1}$ query time of the BinIndex.
		
		\subsubsection{Visibility graph generation overview}
		
			The following steps, which are described in detail in the following sections, are performed to determine all visibility neighbors of a vertex:
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.},label={2.\arabic*.}]
				\item Determine the obstacle neighbors for each vertex.
				\item Determine the visibility neighbors of every convex hull vertex.
				\item Sort the visibility neighbors into bins based on the obstacle neighbors.
			\end{enumerate}
		
		\subsubsection{Step 2.1: Determining obstacle neighbors}
			
			Obstacle neighbors are needed to correctly handle the closed surface of obstacles, especially when two obstacles touch each other.
			This handling of neighbors is then used to form the valid angle areas used for vertex filtering as described in \Cref{subsubsec:valid-angle-areas}.
			
			Determining the obstacle neighbors is relatively simple and straightforward.
			Each vertex $v$ of an obstacle $o$ is processed by looking at the previous and next vertices $v_p$ and $v_n$ on the same obstacle, which are both potential obstacle neighbors.
			If the line segment $(v, v_p) \in o$ (the same applies to $v_n$) does not intersect with any other obstacle and no other obstacle contains this edge as well (i.e. if no other obstacle touches $o$ at this edge), it is considered an obstacle neighbor.
			Latter case can be seen in \Cref{fig:obstacle-neighbors-touching} at the line segment $(v_1, v_3)$, which is part of the two touching obstacles.
						
			\begin{figure}[h]
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot[label={[text=gray]below:$v_0$},gray]{(0,0)}{v0}
							\tikzDot[label=above:$v_1$]{(1,1.5)}{v1}
							\tikzDot[label=below:$v_2$]{(2,0)}{v2}
							\tikzDot[label=above:$v_3$]{(3,1.5)}{v3}
							\tikzDot[label={[text=gray]below:$v_4$},gray]{(4,0)}{v4}
							
							\draw[gray] (v0) -- (v1);
							\draw[->,very thick] (v2) -- (v1);
							\draw[->,very thick] (v2) -- (v3);
							\draw[gray] (v3) -- (v4);
						\end{tikzpicture}
					\end{figcenter}
					\caption[Illustration of line-based obstacle neighbors.]{The black arrows point to the obstacle neighbors $v_1$ and $v_3$ of $v_2$.}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{0.475\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\def\d{1.5}
							
							\tikzDot[gray]{(0,0)}{c00}
							\tikzDot[label=above:$v_0$]{(0,\d)}{v0}
							\tikzDot[label=above:$v_1$]{(\d,\d)}{v1}
							\tikzDot[label=above:$v_2$]{(2*\d,\d)}{v2}
							\tikzDot[label={[text=gray]below:$v_3$},gray]{(\d,0)}{v3}
							\tikzDot[gray]{(2*\d,0)}{c20}
							
							\node at (0.5*\d,0.5*\d) {$o_1$};
							\node at (1.5*\d,0.5*\d) {$o_2$};
							
							\draw[gray] (c00) -- (v0);
							\draw[gray] (c00) -- (v3);
							\draw[->,very thick] (v1) -- (v0);
							\draw[->,very thick] (v1) -- (v2);
							\draw[->,gray] (v1) -- (v3);
							\draw[gray] (c20) -- (v3);
							\draw[gray] (c20) -- (v2);
						\end{tikzpicture}
					\end{figcenter}
					\caption[Illustration of obstacle neighbors on touching polygons.]{The black arrows point to the obstacle neighbors $v_0$ and $v_2$ of $v_1$. Vertex $v_3$ is also a neighbor, but hidden because $o_1$ and $o_2$ touch each other at the edge $(v_1, v_3)$.}
					\label{fig:obstacle-neighbors-touching}
				\end{minipage}
			\end{figure}
			
			As shown in the next step, obstacle neighbors are crucial to a correct edge generation.
			The \texttt{AddObstacleNeighborsForObstacles} method in the \texttt{VisibilityGraphGenerator} class implements this important procedure.
			
		\subsubsection{Step 2.2: Determining visibility neighbors}
		
			The \texttt{VisibilityGraphGenerator} class also contains the necessary methods to determine the visibility neighbors for every vertex.
			Essential to this process is the \texttt{GetVisibilityNeighborsForVertex} method determining the visibility neighbors for a single vertex.
			This method uses the concept of shadow areas stored in a BinIndex structure with a bin count of 360, each bin covering a 1° area.
			For any given vertex $v$, the following steps are performed for every potential visibility neighbor $u$:
			\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.},label={2.2.\arabic*.}]
				\item Continue with the next potential visibility neighbor if any of this is true: $u$ is in a shadow area, $u$ is outside a valid angle area or $u$ is not part of any convex hull.
				\item If none of the above condition applies to $u$, query all obstacles in the extent spanned by $v$ and $u$. For each obstacle $o$, perform the following steps:
				\begin{enumerate}[leftmargin=2.25em+\widthof{2.2.}-1em]
					\item Create the shadow area $S$ for $o$.
					\item If $u \in S$, mark $u$ as hidden and skip all subsequent obstacles and continue with the next potential visibility neighbor.
					\item If $u \not\in S$ but still within the angular range of $S$, perform a full visibility check as described in \Cref{subsubsec:intersection-checks} and mark $u$ as hidden if the check was positive.
				\end{enumerate}
				\item If $u$ has been marked as hidden, continue with the next potential visibility neighbor.
				\item If $u$ is visible, store it in the according bin for its angle and continue with the next vertex.
			\end{enumerate}
			All visibility neighbors for $v$ are grouped based on the angular ranges of $v$'s obstacle neighbors.
			This procedure is described in the following section and its result is stored for the graph creation, which is described below in \Cref{subsec:step-3-graph-creation}.
		
		\subsubsection{Step 2.3: Sort resulting visibility neighbors into bins}
		\label{subsubsec:sort-visibility-neighbors}
		
			A naive approach to create a visibility graph would be to create edges between vertices that are visible to each other.
			This would make routing through line-based obstacles possible, as \Cref{fig:routing-through-line-obstacle} illustrates.
			Such routing behavior is, of course, not desired.
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\tikzDot{(2,0)}{vo0};
								\tikzDot[label={[label distance=-1.25mm]above right:$v $}]{(2,1)}{vo1};
								\tikzDot{(2,2)}{vo2};
								
								\draw (vo0) -- (vo1);
								\draw (vo1) -- (vo2);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo1);
								\draw[dotted] (vo1) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption[Naive node and visibility edge creation.]{
							Visibility graph with naive connections.
							The two dotted visibility edges at $v$ allow a shortest path to go through the obstacle from $n_a$ via $v$ to $n_b$.
						}
						\label{fig:routing-through-line-obstacle-a}
					\end{subfigure}
					\hfill
					\begin{subfigure}[t]{.48\textwidth}
						\begin{figcenter}
							\begin{tikzpicture}
								\def\r{0.85mm}
								\def\rMargin{1.1mm} % = r + 0.25mm
								\def\gap{0.1875mm}
								
								\tikzDot{(2,0)}{vo0};
								\node (vo1) at (2,1) {};
								\node[label={[label distance=-1.25mm]above left:$v_a$}] at (vo1) {};
								\node[label={[label distance=-1.25mm]above right:$v_b$}] at (vo1) {};
								\coordinate (vo11) at ($(vo1)+(180:\rMargin)$);
								\coordinate (vo12) at ($(vo1)+(0:\rMargin)$);
								\tikzDot{(2,2)}{vo2};
								
								\filldraw (vo1)++(-\gap,0)++(90:\r) arc (90:270:\r);
								\filldraw (vo1)++( \gap,0)++(90:\r) arc (90:-90:\r);
								
								\draw ($(vo1)+(270:\r)+(-0.275mm,0)$) -- ($(vo0)+(-0.275mm,2mm)$) -- (vo0.north);
								\draw ($(vo1)+(270:\r)+( 0.275mm,0)$) -- ($(vo0)+( 0.275mm,2mm)$) -- (vo0.north);

								\draw ($(vo1)+(90:\r)+(-0.275mm,0)$) -- ($(vo2)+(-0.275mm,-2mm)$) -- (vo2.south);
								\draw ($(vo1)+(90:\r)+( 0.275mm,0)$) -- ($(vo2)+( 0.275mm,-2mm)$) -- (vo2.south);
								
								\tikzDot[label=left:$n_a$,outer sep=0.5mm]{(0.5,1.3)}{n1};
								\tikzDot[label=right:$n_b$,outer sep=0.5mm]{(3.5,1)}{n2};
								
								\draw[dotted] (n1) -- (vo11);
								\draw[dotted] (vo12) -- (n2);
								
								\draw[dotted] (n1) -- (vo0);
								\draw[dotted] (n1) -- (vo2);
								\draw[dotted] (n2) -- (vo0);
								\draw[dotted] (n2) -- (vo2);
							\end{tikzpicture}
						\end{figcenter}
						\caption[Correct visibility edge creation with duplicated vertices.]{
							The visibility graph with connection respecting the obstacle. Vertex $v$ is split into two, $v_a$ and $v_b$, but with exact same location (all gaps are for illustration purposes only).
							However, $v_a$ and $v_b$ are not connected, which ensures that a shortest path from $n_a$ to $n_b$ does not lead through the middle vertex of the obstacle.
						}
						\label{fig:routing-through-line-obstacle-b}
					\end{subfigure}
				\end{figcenter}
				\caption[Naive and correct connection of vertices.]{
					Both illustrations show two of $v$'s visibility neighbors $n_a$ and $n_b$ next to a vertical obstacle. 
					The dotted lines are visibility edges and the solid lines are normal line segments of the obstacle.
				}
				\label{fig:routing-through-line-obstacle}
			\end{figure}
			
			\begin{figure}[h]
				\begin{figcenter}
					\begin{tikzpicture}
						\def\d{0.03}
						
						\tikzDot[label=below:$v$]{(0,0)}{v}
						
						\tikzDot[label=left:$n_1$]{(-2.25,0)}{n1}
						\tikzDot[label=above:$n_2$]{(0,2)}{n2}
						\tikzDot[label=right:$n_3$]{(2.25,0)}{n3}
						
						\draw[lightgray] (v) -- (n1);
						\draw[lightgray] (v) -- (n3);
						\draw[lightgray] (v) -- (n2);
						
						% Visibility edges to n1
						\tikzDot[DodgerBlue3]{(-1.1,-0.25)}{vn1}
						\tikzDot[DodgerBlue3]{(-1.6,-0.9)}{vn2}
						\tikzDot[DodgerBlue3]{(1.6,-0.5)}{vn3}
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn1);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn2);
						\draw[DodgerBlue3,densely dashed,->] (v) -- (vn3);
						
						% Visibility edges to n3
						\tikzDot[Red2]{(0.7,1.4)}{vn4}
						\tikzDot[Red2]{(2,1)}{vn5}
						\draw[Red2,densely dotted,->] (v) -- (vn4);
						\draw[Red2,densely dotted,->] (v) -- (vn5);
						
						% Visibility edges to n2
						\tikzDot[Green4]{(-2,1.3)}{vn6}
						\draw[Green4,dashdotted,->] (v) -- (vn6);
					\end{tikzpicture}
				\end{figcenter}
				\caption[Example of vertices sorted into obstacle neighbor-based bins.]{
					All visible neighbors of $v$, colored by their resulting bin.
					The neighbors $n_1$, $n_2$ and $n_3$ are added to both adjacent bins, for example, $n_2$ is added to the green (left) and red (right) bins.
				}
				\label{fig:visibility-bin-sorting}
			\end{figure}
			
			To correctly split and connect vertices, it must be known which visibility neighbors are within the angular range of which two obstacle neighbors.
			\Cref{fig:visibility-bin-sorting} illustrates this by differently colored visibility neighbors of $v$, resulting in three bins for each of the three angular regions.
			Therefore, each bin of a vertex covers the area between two adjacent obstacle neighbors.
			Later, in \hyperref[subsec:step-3-graph-creation]{step 3} of the overall algorithm, each bin leads to one new vertex, which is connected to the corresponding visibility neighbors as illustrated by \Cref{fig:routing-through-line-obstacle-b}.
			
	\subsection{Step 3: Visibility graph creation}
	\label{subsec:step-3-graph-creation}
	
		The third step is the graph generation using the grouped visibility neighbors from the previous step.
		One vertex is created for each visibility neighbor bin, which corresponds to the angular range between two adjacent obstacle neighbors.
		To correctly connect vertices in the output graph, as described in \Cref{subsubsec:sort-visibility-neighbors}, mappings between output vertices in the generated graph, input vertices of the dataset and visibility neighbor bins have to be created.
		
		Two iterations over all vertices are performed.
		The first iteration is used to create one output vertex per bin (so-called \emph{bin-vertex}) and to create a mapping of each newly bin-vertex to the corresponding original input vertex.
		In \Cref{fig:routing-through-line-obstacle}, $v_a$ and $v_b$ are the bin-vertices corresponding to the obstacle vertex $v$.
		In a second iteration, this mapping is used to correctly connect each bin-vertex $u$ to every other bin-vertex which bin contains $u$.
		\Cref{fig:bin-vertex-connection} illustrates this with two bin-vertices and color-coded angular ranges of the bins:
		The bin-vertex $v$ is connected to bin-vertex $u$ because the bin of $u$ contains $v$.
		The same applies to $u$ being connected to $v$ since $u$ is within $v$'s bin.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{tikzpicture}
					\coordinate (cv) at (0,0);
					\coordinate (cu) at (4,0.75);
					
					\def\pad{\pgflinewidth}
					\def\d{0.4}
					\def\dsmall{0.3}
					
					\filldraw[line width=0,Green4!25!white] (cv)++(292.5:\pad) -- +(180:\d) arc [start angle=180, delta angle=225, radius=\d];
					\filldraw[line width=0,Red2!25!white] (cv)++(112.5:\pad) -- +(45:\dsmall) arc [start angle=45, delta angle=135, radius=\dsmall];
					
					\filldraw[line width=0,Green4!25!white] (cu)++(180:\pad) -- +(0:\d) arc [start angle=0, delta angle=225, radius=\d];
					\filldraw[line width=0,DodgerBlue3!25!white] (cu)++(292.5:\pad) -- +(225:\dsmall) arc [start angle=225, delta angle=135, radius=\dsmall];
					
					\tikzDot[color=Green4!80!black,label={below:\contour{white}{$v$}}]{($(cv)+(292.5:0.05)$)}{v}
					\tikzDot[color=Green4!80!black,label={above:\contour{white}{$u$}}]{($(cu)+(112.5:0.05)$)}{u}
					
					\draw (cv) -- +(45:1);
					\draw[dotted] (cv)++(45:1) -- +(45:0.3);
					\draw (cv) -- +(180:1);
					\draw[dotted] (cv)++(180:1) -- +(180:0.3);
					
					\draw (cu) -- +(0:1);
					\draw[dotted] (cu)++(0:1) -- +(0:0.3);
					\draw (cu) -- +(225:1);
					\draw[dotted] (cu)++(225:1) -- +(225:0.3);
					
					\draw[dashed] (v) -- node[above] {$e$} (u);
				\end{tikzpicture}
			\end{figcenter}
			\caption[Usage of obstacle neighbor-based bins for visibility edge creation.]{Edge $e$ connecting the two bin-vertices $v$ and $u$ corresponding to the green angular ranges representing the bins of $v$ and $u$.}
			\label{fig:bin-vertex-connection}
		\end{figure}
		
		Without a mapping between bin and bin-vertex, it would not be clear to which vertex to connect since all bin-vertices of the same input vertex have the exact same location, which is the problem illustrated earlier in \Cref{fig:routing-through-line-obstacle}:
		Without such a mapping, it would be unclear whether to connect $n_a$ to $v_a$ or to $v_b$.
		Both are on the exact same location but correspond to different angular ranges.
		
		The resulting spatial graph, together with some of the mappings, which will also be used to \hyperref[sec:answering-queries]{answer routing queries}, are stored in an instance of the \texttt{HybridVisibilityGraph} class.
		It contains an instance of the \texttt{SpatialGraph} class, provided by the MARS framework, along with all data needed to correctly add and connect new vertices during routing.
		
	\subsection{Step 4: Merging a road network into the visibility graph}
	\label{subsec:step-4-graph merging}
	
		Allowing a route to alternate between road and visibility edges, required the road network to be merged into the visibility graph.
		This is done by cutting and connecting all road and visibility edges at their intersection points, as illustrated in \Cref{fig:merging-edges}.
		This final graph allows any routing algorithm to switch between road and visibility edges without further instructions or adjustments to the existing routing algorithm.

		In the following, all edges are bidirectional and counted once, even though the MARS implementation of the \texttt{SpatialGraph} models bidirectional edges as two separate directed edges.
		The runtime complexity of the road merge operation is in $\bigo{|E_R| \cdot |E_V|}$ with $E_R$ containing all road and $E_V$ all visibility edges.
		This complexity arises from the fact that a road segment intersecting with $n$ visibility edges leads to $n$ additional road segments, $n$ new intersection vertices and $n$ new visibility edges connecting them.
		In the worst case, a road segment intersects with all $|E_V|$ many visibility edges increasing the number of edges by $2 \cdot |E_V|$ and the number of vertices by $|E_V|$.
		Therefore, up to $|E_R| \cdot 2 \cdot |E_V|$ new edges and $|E_R| \cdot |E_V|$ new vertices are created.
		This means that, even though runtime is linear in the input size $|E_R|$, the size of the output graph is significantly higher than of the input graph.
		Fortunately, as shown in \Cref{subsec:design-merge-road-network}, road networks are typically very sparse networks.
		
		\begin{figure}[h]
			\begin{figcenter}
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\draw[<->,dashed] (v1n1) -- node[above right=0cm and 0.4cm] {$v$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above right=0cm and 0.4cm] {$u$} (v2n2);
							
							\draw[<->] (rn1) -- node[left] {$r$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption[Road and visibility edges before merging.]{
						Before merging $r$ into the graph with six vertices and six edges.
					}
					\label{fig:merging-edges-a}
				\end{subfigure}
				\hfill
				\begin{subfigure}[t]{.48\textwidth}
					\begin{figcenter}
						\begin{tikzpicture}
							\tikzDot{(0,-0.75)}{v1n1}
							\tikzDot{(4,-0.6)}{v1n2}
							
							\tikzDot{(0,0.8)}{v2n1}
							\tikzDot{(4.2,0.6)}{v2n2}
							
							\tikzDot{(1.5,-1.65)}{rn1}
							\tikzDot{(1.8,1.65)}{rn2}
							
							\tikzDot{(intersection of v1n1--v1n2 and rn1--rn2)}{i1}
							\tikzDot{(intersection of v2n1--v2n2 and rn1--rn2)}{i2}
							
							\draw[<->,dashed] (v1n1) -- node[above] {$v_1$} (i1);
							\draw[<->,dashed] (i1)   -- node[above] {$v_2$} (v1n2);
							\draw[<->,dashed] (v2n1) -- node[above] {$u_1$} (i2);
							\draw[<->,dashed] (i2)   -- node[above] {$u_2$} (v2n2);
							
							\draw[<->] (rn1) -- node[right] {$r_1$} (i1);
							\draw[<->] (i1)  -- node[right] {$r_2$} (i2);
							\draw[<->] (i2)  -- node[right] {$r_3$} (rn2);
						\end{tikzpicture}
					\end{figcenter}
					\caption[Road and visibility edges after merging.]{
						After correctly splitting and merging $r$. The graph size increases by one vertex and four directed edges per intersection.
					}
					\label{fig:merging-edges-b}
				\end{subfigure}
			\end{figcenter}
			\caption{
				Merging the road edge $r$ with two bidirectional visibility edges $v$ and $u$.
			}
			\label{fig:merging-edges}
		\end{figure}
	
\section{Answering shortest path queries}
\label{sec:answering-queries}

	The process of answering routing queries is directly implemented in the \texttt{HybridVisibilityGraph} class and a custom weighting function can be passed to alter the routing behavior.
	The implementation performs the following steps:
	\begin{enumerate}
		\item \label{itm:answering-queries-add-vertices} Add vertices at the source and destination locations of the routing query to the graph.
		\item \label{itm:answering-queries-vis-edges} Determine visibility edges for the two newly created vertices and add them to the graph.
		\item \label{itm:answering-queries-routing} Use a normal shortest path algorithm, such as A*, together with a weight function to find the optimal path from the source to the destination.
		\item \label{itm:answering-queries-cleanup} Remove all previously added vertices and edges to restore the augmented graph to the original one to have a clean state for future routing requests.
	\end{enumerate}
	Steps \ref{itm:answering-queries-add-vertices}, \ref{itm:answering-queries-vis-edges} and \ref{itm:answering-queries-cleanup} are only performed for newly added vertices, i.e. for locations that did not already exists in the graph.
	
	Because step \ref{itm:answering-queries-vis-edges} is already implemented for the general graph generation, the core method \texttt{VisibilityGraphGenerator.GetVisibilityNeighborsForVertex()} can be used without further adjustments.
	The most complex part is to determine the correct existing vertices to connect to.
	Thanks to the mappings of neighbor bins and their covered angle areas, created during \hyperref[subsec:step-3-graph-creation]{graph generation}, the correct bin for each newly added vertex can be determined and a bidirectional edge be created.
	The implementation required very little code and only simple filtering operations on the bins.
	
	As mentioned above, the graph-based shortest path algorithm, A* in this implementation, can now be executed on the augmented graph.
	
	Fortunately, for the clean-up step performed after the shortest path has been determined, the \texttt{SpatialGraph.RemoveNode(int)} method removes the vertex given by its ID and also removes all adjacent edges.
	This makes step \ref{itm:answering-queries-cleanup} very easy since step \ref{itm:answering-queries-add-vertices} and \ref{itm:answering-queries-vis-edges} yield the IDs of all created vertices.
	
	The performance of routing and quality of the determined routes depend on several factors, with are discussed in the next chapter.