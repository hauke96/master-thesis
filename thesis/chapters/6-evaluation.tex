% !TEX root = ../thesis.tex
% !TeX spellcheck = en_US

The implementation of the hybrid routing algorithm was evaluated regarding performance and usefulness, which is covered in this chapter.
For both evaluation aspects, method and design details are given followed by the respective results of the evaluations.

\section{Performance evaluation}

	The performance evaluation uses different datasets to measure graph generation and routing times.
	Each of these two steps is measured more fine-grained by measuring the execution times of separate method calls.
	The datasets have different properties and sizes and consist of artificial and real-world data.

	\subsection{Methods \& Measurements}

		\subsubsection{Collected data}
		
			The collected data consists of time measurement, many of them on the level of separate methods.
			Also, the amount of data is measures, namely the number of edges and vertices at various steps in the process.
			
			As a result, two CSV files are written per dataset containing measurement data for the import (including graph generation) and routing.
			The measurement for the routing requests also contains information about the lengths of the routes, especially beeline and actual route distances.
			
			% TODO table with all columns of the measured data including a description and example value?
		
		\subsubsection{Datasets}
		\label{subsubsec:eval-datasets}
		
			There are multiple categories of datasets that were used.
			Pattern-based datasets are created using a pattern, e.g. a set of rectangles, repeated numerous times to create datasets of various sizes.
			OSM-based datasets use differently sized extracts from OpenStreetMap.
			While the OSM-based datasets contain obstacles and roads (except in the \enquote{without roads/obstacles} datasets), the pattern-based datasets do no contain any roads.
			
			\begin{description}
				\item[Maze pattern] Datasets of this category are made of maze like geometries, meaning it only contains connected linestrings forming a seamless pattern. Many of the contained line obstacles are collinear.
				\item[Rectangle pattern] Pattern-based datasets, which contain simple rectangles of different sizes.
				\item[Circle pattern] Like the rectangle datasets but with circles, i.e. polygons with a large number of vertices.
				\item[OSM city] Real-world extracts from the OpenStreetMap database with data from the city of Hamburg, Germany. The data has been filtered to remove all over- and underground features. These datasets contain all roads in the respective region.
				\item[OSM rural] Equivalent to the \enquote{OSM city} dataset, but located outside the city of Hamburg and therefore containing more natural obstacles (lakes, ditches, forest), more open spaces and less regular distribution of buildings.
				\item[OSM export without roads] OSM extracts but without the roads. They are used to show the influence of roads on the graph generation and routing times.
				\item[OSM export without obstacles] Analogous to the \enquote{OSM export without roads} category, but without the obstacles, i.e. buildings, walls and natural areas such as lakes and forests. This is used to show the influence of the obstacles on the graph generation and routing times.
			\end{description}
			The \enquote{OSM city} and \enquote{OSM rural} categories each contain six dataset of the sizes 0.5, 1, 1.5, 2, 3 and 4 km\textsuperscript{2}.
			The two OSM categories \enquote{without roads/obstacles} both use the 4 km\textsuperscript{2} datasets from the city and rural categories.
			
			\begin{figure}[h!]
				\centering
				\begin{minipage}[t]{.38\textwidth}
					\begin{figcenter}
						\includegraphics[width=\textwidth]{images/qgis-overview-city-rural_city}
					\end{figcenter}
				\end{minipage}
				\hspace{0.04\textwidth}
				\begin{minipage}[t]{.38\textwidth}
					\begin{figcenter}
						\includegraphics[width=\textwidth]{images/qgis-overview-city-rural_rural}
					\end{figcenter}
				\end{minipage}
				\caption{All six regions from 0.5km\textsuperscript{2} to 4km\textsuperscript{2} of the \enquote{OSM city} datasets (left) and \enquote{OSM rural} datasets (right).}
			\end{figure}
		
		\subsubsection{Optimizations}
		
			As described in \Cref{chap:implementation}, there were several optimizations made to the implementation.
			Some of which are on the level of data structures, some on algorithmic level.
			The effectiveness of these optimization was also evaluated using the OSM dataset.
			Each of the following optimizations was deactivated or replaced for the evaluation:

			\begin{description}
				\item[Shadow areas] Instead, every visibility check was performed using the custom intersection check described in \Cref{subsubsec:intersection-checks}.
				\item[Custom intersection check] The custom intersection check was replaced by the \texttt{RobustLineIntersector} class from the NTS to determine intersections between line segments.
				\item[BinIndex] Instead, the \texttt{Bintree} from the NTS was used.
				\item[Convex hull] The restriction to only consider vertices on the convex hull of obstacles was removed.
				\item[Valid angle areas] Considering only potential visibility neighbors within certain angular ranges was deactivated.
				\item[$k$-NN search] The $k$ of the k-NN search was deactivated to determine all visibility neighbors in all directions.
			\end{description}		
			
		\subsubsection{Measurement method}
		
			Measuring the performance was done by a small agent-based simulation project called \texttt{HikerModel}, which consists of one agent, a list of coordinates and the input dataset.
			The coordinates are given via a linestring within a GeoJSON file and each coordinate in this linestring is visited by the agent using the hybrid routing algorithm to determine the path from one location the the next.
%			The time of the graph generation as well as the time of each routing request are measured.
			Each waypoint was within the range of the dataset, meaning each coordinate was surrounded by obstacles.
			The euclidean distances (beeline distances) of the line segments within this linestring were distributed evenly to measure the required routing time relative to the distance and dataset size.
			
			Because the OSM datasets within one category cover differently sized areas, each waypoint linestring of a dataset contains all waypoints of the next smaller one plus some additional ones.
			This the waypoints of the smallest dataset are used by every other dataset as well.
%			In other words, the second smallest dataset contains all waypoints of the smallest plus some additional ones.
%			The third smallest contains all waypoints of the second smallest plus some additional ones, and so on.
		
		\subsubsection{Technical considerations}
		
			The measurement was done by a helper class \texttt{PerformanceMeasurement} providing a method accepting a function delegate which execution time is then measured.
			
			As part of its memory management, C\#/.NET uses automatic garbage collection adding unavoidable noise to the measurements.
			Unfortunately the garbage collector cannot be turned off and controling it is only partially possible.
		
			C\#/.NET also uses just-in-time (JIT) compilation changing the code during runtime.
			This can also not be turned off for normal .NET executions via the command \texttt{dotnet program.dll}.
			An alternative would be the usage of ahead-of-time (AOT) compilation, which has a negative impact on the performance of LINQ operations\footnote{According to \url{https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=net7}}, which in turn are used very often in the implementation.
			Because both compilation strategies have disadvantages, the normal .NET-based execution was chosen, even though it contains JIT compilation.
			
			To mitigate this dynamic behavior and to generally get resilient results, the import and each routing request was performes multiple times.
			Precisely, three warm-up iterations were performed before measuring the times of five actual execution iterations.
			The execution times from the warm-up iterations indicated that three warm-up iterations were enough for the runtime to perform the JIT compilation and prepare the garbage collector.
			
			Additionally, the garbage collector was triggered during each of the eight iterations just before calling the measured function with the goal to provide equal circumstances to all iterations.
			This was done by the \texttt{GC.Collect()} and \texttt{GC.WaitForPendingFinalizers()} methods from the \texttt{GC} class of the .NET framework.
			Using these two methods forces a garbage collection and waits for it to finish\cite{ms-gc}.
			
			To prevent the garbage collection from interfering with the execution, a 256 MiB large no-GC-region is placed around the function call via \texttt{GC.TryStartNoGCRegion(256 * 1024 * 1024)}.
			This only works if enough memory is available\cite{ms-no-gc-region}, which was the case, and introducing this no-GC-region reduced the variance of the measured times.
			\todo[inline]{\enquote{reduced the variance of the measured times} \textrightarrow\ measure/test this?}
			
			Another step to get stable and reproducable results was the increase of the process priority.
			This aims to the exclusive use of one CPU core on which this single threaded application ran.
			Increasing the process priority was done by settings the \texttt{PriorityClass} property of the current process to \texttt{ProcessPriorityClass.High}, which required root permissions on Linux systems.
		
		\subsubsection{System and hardware}
		
			The measurements were performed on an up-to-date Arch Linux operating system (Kernel 6.4.3) with .NET Core 7.0.107 and MARS framework 4.5.2.
			Apart from necessary operating system processes and the simple desktop environment i3, no other applications ran during the performance measurements.
			
			The hardware consisted of an octa core Intel\textregistered\ Xeon\textregistered\ E3-1231 v3 CPU at 3.40 GHz, a total of 16GB DDR3 1333 MHz RAM and a Samsung EVO 850 SSD.
			However, the whole algorithm and the \texttt{HikerModel} simulation is single threaded.
			File system operations are only performed to initially load the input data and to write the results after performaing all measurements.
	
\section{Performance evaluation}

	In this section the results of the performance evaluation of the algorithm are presented.
	First the OSM-based datasets are discussed followed by the artificial pattern-based datasets.

	\subsection{OSM-based datasets}
		
		\subsubsection{Import and graph generation}
		
			A few aspects regarding the runtime behavior can be inferred from the general graph generation times shown in \Cref{fig:eval-import-city} and \Cref{fig:eval-import-rural}.
			
			\begin{figure}[h!]
				\begin{minipage}{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-import-time-per-vertices.py_absolute.pgf}
						\end{figcenter}
						\caption{Total graph generation times.}
						\label{fig:eval-import-city-abs}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-import-time-per-vertices.py_per-vertex.pgf}
						\end{figcenter}
						\caption{Graph generation times per input vertex.}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-import-time-per-vertices.py_per-vertex-added.pgf}
						\end{figcenter}
						\caption{Increase in graph generation time per additionally added vertex.}
						\label{fig:eval-import-city-rel-increase}
					\end{subfigure}
					\caption{Graph generation times using the \enquote{OSM city} dataset.}
					\label{fig:eval-import-city}
				\end{minipage}
				\hfill
				\begin{minipage}{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-import-time-per-vertices.py_absolute.pgf}
						\end{figcenter}
						\caption{Total graph generation times.}
						\label{fig:eval-import-rural-abs}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-import-time-per-vertices.py_per-vertex.pgf}
						\end{figcenter}
						\caption{Graph generation times per input vertex.}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-import-time-per-vertices.py_per-vertex-added.pgf}
						\end{figcenter}
						\caption{Increase in graph generation time per additionally added vertex.}
						\label{fig:eval-import-rural-rel-increase}
					\end{subfigure}
					\caption{Graph generation times using the \enquote{OSM rural} dataset.}
					\label{fig:eval-import-rural}
				\end{minipage}
			\end{figure}
			
			First of all and as mentioned at the beginning of \Cref{subsec:related-work:visibility-graph}, the process of generating a visibility graph has an inherent quadratic runtime.
			This fact is clearly visible in measurements of the dataset imports illustrated in \Cref{fig:eval-import-city-abs} and \Cref{fig:eval-import-rural-abs}, even though it is less prominent in the \enquote{OSM rural} datasets.
			Details on the contribution of each task to the overall graph generation time can be seen in \Cref{fig:eval-import-details}.
			
			Second, \Cref{fig:eval-import-city-rel-increase} and \ref{fig:eval-import-rural-rel-increase} show the increase in the per-vertex processing time when a new additional vertex is added to the dataset.
			A value of 1µs means, that the processing time of every vertex increases by 1µs when the dataset size increases by one vertex.
			This value is very low for the \enquote{OSM city} datasets (around 0.2µs) and even decreases within the \enquote{OSM rural} datasets from 3.3µs to 0.35µs.
			However, the \enquote{OSM city} datasets indicate that this value might increase again with larger dataset sizes.
			This significantly different behavior is very likely influenced by the type of dataset, i.e. the distribution of obstacles and size of the dataset.
			Pattern-based datasets showed a runtime behavior similar to the OSM-based datasets with decreasing times for smaller and increasing times for larger datasets, which is another indicator that the effect from \Cref{fig:eval-import-rural-rel-increase} is caused by the size of the dataset.
			A decrease in this per-vertex time increase has no directly noticeable effect on the overall graph generation time, which still shows a quadratic increase.
			
			\begin{figure}[h!]
				\begin{figcenter}
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-import-details-per-vertices.py_absolute.pgf}
						\end{figcenter}
						\caption{Import time of the \enquote{OSM city} dataset by tasks.}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-import-details-per-vertices.py_absolute.pgf}
						\end{figcenter}
						\caption{Import time of the \enquote{OSM rural} dataset by tasks.}
					\end{subfigure}
				\end{figcenter}
				\caption{Details of graph generation times for the two datasets \enquote{OSM city} (above) and \enquote{OSM rural} (below).}
				\label{fig:eval-import-details}
			\end{figure}
			
			In \Cref{fig:eval-import-details} both OSM dataset import times are split into the performed tasks.
			The task with the largest effort in terms of the required time differs from the dataset category.
			
			In the \enquote{OSM city} datasets, the $k$ nearest neighbor (kNN) search is the most time consuming task with a share on the total time of constantly over 60\%.
			The second most time consuming task is the merge operation, where visibility and road edges are merged and connected
			Together, these two steps are responsible for over 98.1\% of the required graph generation time.
			
			A different situation can be found in the \enquote{OSM rural} dataset.
			Here, the merge operation is the heavier task with a share of at least 51.4\% on the overall graph generation time.
			This effect of a more time-consuming merge operation is further discussed in \Cref{subsubsec:dataset-without-roads-obstacles}.
			The times of the kNN search and the merge operation sum up to 96.5\% of the graph generation time.
			
			Even though the order which task is the heaviest is different, both runtimes of the kNN search and the merge operation are the most significant ones.
			The graph creation task in the \enquote{OSM rural} datasets is the only additional task throughout all tasks in all OSM-based datasets with a share of over 1\%.
			All other tasks have a negligible share on the total graph generation time of below 1\%, which decrease with the size of the dataset.
	
		\subsubsection{Routing}
		
			Routing consists of several tasks with varying degrees of impact on the total routing time.
			The time required for a routing task is influenced by two main factors.
			First, the dataset size is a strong influencing factor but has differently large impacts on the time of the routing tasks.
			Second, the structure of the data, meaning the number, size and distribution of obstacles, also influences the required time for routing.
			In fact, the size of the dataset is the strongest influence on the overall routing time as it affects all tasks during routing.
			
			\Cref{fig:eval-city-routing-details} and \ref{fig:eval-rural-routing-details} show the routing times from the \enquote{OSM city} and \enquote{OSM rural} datasets as well as details on the separate tasks during routing.
		
			\clearpage
			\begin{figure}[h!]
				\begin{figcenter}
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-routing-time.py_distance.pgf}
						\end{figcenter}
						\caption{Total routing times of all datasets.}
						\label{fig:eval-city-routing-details-a}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-routing-time-details.py_absolute_45018.pgf}
						\end{figcenter}
						\caption{Each task during routing of the largest dataset with 45018 input vertices.}
						\label{fig:eval-city-routing-details-b}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-routing-time-details.py_relative_45018.pgf}
						\end{figcenter}
						\caption{Same as \Cref{fig:eval-city-routing-details-b} but showing the relative shares on the total time.}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-city/plot-routing-time-details.py_absolute_all.pgf}
						\end{figcenter}
						\caption{Routing between the same waypoints appearing in all datasets (distance between the waypoints: 600 m).}
					\end{subfigure}
				\end{figcenter}
				\caption{Routing time statistics of the \enquote{OSM city} datasets.}
				\label{fig:eval-city-routing-details}
			\end{figure}
			
			\clearpage
			\begin{figure}[h!]
				\begin{figcenter}
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-routing-time.py_distance.pgf}
						\end{figcenter}
						\caption{Total routing times of all datasets.}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-routing-time-details.py_absolute_06055.pgf}
						\end{figcenter}
						\caption{Detailed routing times of the largest dataset with 6055 input vertices.}
						\label{fig:eval-rural-routing-details-b}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-routing-time-details.py_relative_06055.pgf}
						\end{figcenter}
						\caption{Same as \Cref{fig:eval-rural-routing-details-b} but showing the relative shares on the total time.}
					\end{subfigure}
					\\[3ex]
					\begin{subfigure}[t]{\textwidth}
						\begin{figcenter}
							\input{images/evaluation/osm-based-rural/plot-routing-time-details.py_absolute_all.pgf}
						\end{figcenter}
						\caption{Routing between the same waypoints appearing in all datasets (distance between the waypoints: 600 m).}
					\end{subfigure}
				\end{figcenter}
				\caption{Routing time statistics of the \enquote{OSM rural} datasets.}
				\label{fig:eval-rural-routing-details}
			\end{figure}
			
			Starting with the total routing times, both categories show different runtime behavior in terms of the route length.
			While the \enquote{OSM city} datasets shows no correlation between the beeline distance and the routing time, the \enquote{OSM rural} dataset shows a negative correlation (longer distance means shorter routing time).
			
			This negative correlation is most prominent in the largest \enquote{OSM rural} dataset between the first and the fifth routing request.
			Since the majority of the time is needed to connect the source and destination locations to the graph, the presence of nearby obstacles has a significant impact on the routing time.
			As illustrated in \Cref{fig:eval-osm-rural-map}, the destination vertex of the first routing request has no nearby obstacles.
			This means no efficient use of shadow areas can be made resulting in more visibility checks and therefore slower runtime.
			The destination vertex of the fifth request has multiple obstacles nearby casting large shadow areas towards many buildings, which then do not need to be further checked.
			As a result, 86 visibility edges are connected to the source vertex of the first and 18 to the source vertex of the fifth request.
			
			This phenomenon of longer routing times for routing between short distant vertices does not appear in the \enquote{OSM city} dataset due to the high density of obstacles enabling an efficient use of shadow areas.
			But the effect is still visible in \Cref{fig:eval-city-routing-details-a} at the requests with a beeline distance between 0.5km and 1km.
			Requests in this range, which have a longer processing time, contain vertices at junctions or wide roads with only a few surrounding obstacles, which yields longer processing times.
			
			\vspace{3ex}
			\noindent
			\begin{minipage}{\textwidth}
				\begin{minipage}{0.4\textwidth}
					\centering
					\begin{tabularx}{\textwidth}{p{2cm}|X|X}
						\textbf{Request no.}				& 1			& 5			\\\hline
						\textbf{Beeline\newline distance}	& 100.42 m	& 300.78 m	\\\hline
						\textbf{Routing\newline time}		& 519.5 ms	& 127.19 ms	\\\hline
						\textbf{Time per m}					& 5.17 ms	& 0.42 ms
					\end{tabularx}
				\end{minipage}
				\hfill
				\begin{minipage}{0.56\textwidth}
					\centering
					\includegraphics[width=\textwidth]{images/qgis-osm-rural}
				\end{minipage}
				\\
				\begin{minipage}[t]{0.4\textwidth}
					\captionof{table}{Measured values for the first and fifth routing requests illustrated in \Cref{fig:eval-osm-rural-map}.}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{0.56\textwidth}
					\captionof{figure}{The first and fifth routing requests (red arrow between source and destination) with the nearby obstacles (gray). The bidirectional visibility edges of the two destinations are shown in blue and green.}
					\label{fig:eval-osm-rural-map}
				\end{minipage}
			\end{minipage}
			
		\subsubsection{Dataset without roads or obstacles}
		\label{subsubsec:dataset-without-roads-obstacles}
		
			The normal OSM-based datasets contain both, roads and obstacles.
			However, datasets containing only roads or only obstacles are thinkable and can also be used with the hybrid routing algorithm.
			For this evaluation, the 4km\textsuperscript{2} datasets of the \enquote{OSM city} and \enquote{OSM rural} categories were filtered yielding three datasets for each category:
			The normal dataset, one without roads and one without obstacles.
			In the dataset without roads, all road edges were removed which do not cross buildings, meaning building passages remained within this dataset to ensure the reachability of backyards.
			Influences of the two filters are discussed in the following.
			
			\begin{figure}[h!]
				\begin{figcenter}
					\begin{tabularx}{0.95\textwidth}{p{3cm}XXXp{2.25cm}X}
\toprule
\textbf{Operation}	& \textbf{Normal}	& \textbf{No roads}	& \textbf{Decrease compared to normal}	& \textbf{No obstacles}	& \textbf{Decrease compared to normal}	\\
\midrule
kNN search			& 315.86			& 288.69			&  8.60\%								& 0.000011				& 99.9999\%								\\
Create graph		&   0.69			&   0.68			&  0.84\%								& 0.000014				& 99.9999\%								\\
Get obstacles		&   0.30			&   0.29			&  3.28\%								& 0.0095				& 96.82\%								\\
Merge road edges	& 120.13			&  30.79			& 74.37\%								& 0.48					& 99.60\%								\\
Add POI attributes	&   0.054			&   0.025			& 53.81\%								& 0.008					& 85.97\%								\\
\midrule
Total time			& 437.34			& 320.57			& 26.70\%								& 0.53					& 99.88\%								\\
\bottomrule
					\end{tabularx}
				\end{figcenter}
				\vspace{3ex}
				\begin{figcenter}
					\input{images/evaluation/osm-based-city/plot-no-roads-obstacles.py_absolute.pgf}
				\end{figcenter}
				\caption{Comparison of the normal 4km\textsuperscript{2} \enquote{OSM city} dataset (blue) with the same dataset but without roads (orange) and without obstacles (green). All numbers in the table are given in seconds.}
				\label{fig:eval-import-osm-no-roads-obstacles-city}
			\end{figure}
			
			\Cref{fig:eval-import-osm-no-roads-obstacles-city} lists and illustrates the results for the \enquote{OSM city} datasets.
			Some noteworthy insights can be inferred from these data:
			\begin{itemize}
				\item The kNN search and visibility graph creation times were significantly reduced for the dataset without obstacles, which is expected, since both operations take only obstacles into account.
				\item The merge operation for the dataset without roads took longer compared to the dataset without obstacles.
				This is due to the 175 remaining building passages within the \enquote{no roads} dataset, which means this operation still merges road edges and therefore requires some time.
				However, compared to the normal dataset the merge operation only required 25.63\% of the time in the \enquote{no road} dataset, which does not match the number of remaining road edges of 4.82\% (175 edges) compared to the normal dataset (3629 edges).
				Because building passages consist of short segments, their start and end vertices needs to be connected to the rest of the graph.
				This is the case for 742 such dead-end vertices in the normal dataset and for 346 in the dataset without roads, which yields the relatively, with respect to the number of edges, long processing time.
				\item In the \enquote{no obstacles} dataset the merge operation took 0.4\% of the normal time. This is expected, because no visibility graph edges exist and therefore to merge between visibility edges and road edges takes place.
			\end{itemize}
			
			\begin{figure}[h!]
				\begin{tabularx}{0.95\textwidth}{p{3cm}XXXp{2.25cm}X}
\toprule
\textbf{Operation}	& \textbf{Normal}	& \textbf{No roads}	& \textbf{Decrease compared to normal}	& \textbf{No obstacles}	& \textbf{Decrease compared to normal}	\\
\midrule
kNN search			&  5,958			& 5,924				&   0.57\%								&  0.0094				& 99.9998\%								\\
Create graph		&    191.68			&   210.4			&  -9.76\%								&  0.012				& 99.9936\%								\\
Get obstacles		&     42.53			&    40.76			&   4.15\%								&  0.78					& 98.16\%								\\
Merge road edges	&  6,600			&     5.67			&  99.91\%								& 32.79					& 99.5\%								\\
Add POI attributes	&      4.83			&     1.53			&  68.21\%								&  0.42					& 91.26\%								\\
\midrule
Total time			& 12,854			& 6,202				&  51.75\%								& 37.19					& 99.71\%								\\
\bottomrule
				\end{tabularx}
				\vspace{3ex}
				\begin{figcenter}
					\input{images/evaluation/osm-based-rural/plot-no-roads-obstacles.py_absolute.pgf}
				\end{figcenter}
				\caption{Comparison of the normal 4km\textsuperscript{2} \enquote{OSM rural} dataset (blue) with the same dataset but without roads (orange) and without obstacles (green). All numbers in the table are given in milliseconds.}
				\label{fig:eval-import-osm-no-roads-obstacles-rural}
			\end{figure}
			
			\noindent
			\Cref{fig:eval-import-osm-no-roads-obstacles-rural} lists and illustrates the results for the \enquote{OSM rural} datasets.
			There are some differences to the results of the \enquote{OSM city} dataset:
			\begin{itemize}
				\item In contrast to the \enquote{OSM city} dataset, the results show the expected significant reduction in time for the merge operation for the dataset without roads, because no building passages existed in the rural dataset.
				\item A comparison of the kNN search and road merge operations of the normal dataset shows, that the merge operation actually took 10.77\% longer than the kNN search.
				Results of the normal \enquote{OSM city} dataset shows the opposite relation with 61.97\% less time required for the merge operation.
				A possible explanation is the ratio of road to visibility edges, which is 1:33 for the city dataset (for one road edge, 33 visibility edges existed) and 1:264 for the rural dataset.
				This means that more intersections per road edges exist in the rural dataset, which was actually the case:
				Within the city dataset the number of road edges increased by a factor of 66 and within the rural dataset by a factor of 221.
				Therefore, the time spent on one road edge was significantly higher within the rural dataset and likely lead to the significant increase in time required for the merge operation.
				\item The time required by the graph creation in the \enquote{no roads} dataset is especially noteworthy since it shows an increased processing time compared to the normal dataset.
				But because the data was slightly distorted due to outliers and no relation between roads and the graph creation exists, it can be assumed that this increase in time has no algorithmic reason.
			\end{itemize}
			Apart these differences and unique characteristics, both dataset categories also show similar results for the kNN search, graph generation and overall processing time.
			First of all, removing the obstacles removes the main complexity and therefore significantly decreases the processing time.
			Not removing all obstacles, but decreasing their amount might reduce the processing time significantly due to the overall quadratic runtime complexity of the kNN search.
			Second, the kNN search and graph creation are not affected by removed roads.
			The total processing time, however, decreases with removed roads due to the faster merge operation.
			Third, even though it is not a significant part of the processing time in the first place, getting obstacles and adding attributes to points of interests (POIs) is also reduced when removing obstacles or roads.
	
	\subsection{Pattern-based datasets}
	
		\subsubsection{Import and graph generation}
		
			Due to the repeated patterns in the datasets, the distribution of obstacles and vertices is much more regular compared to the OSM-based datasets.
			This is also reflected in the results of the graph generation as seen in \Cref{fig:eval-import-pattern-abs}.
			Due to the lack of roads, the overall graph generation time is determined by the time required by the kNN search.
			Only for smaller datasets of up to an input vertex count of about 3,500 (depending on the dataset category), all other tasks combined had an impact of up to 5\% on the total graph generation time.
			Absolute and relative numbers for the maze dataset can be seen in \Cref{fig:eval-import-pattern-maze-abs-rel}.
			
			\begin{figure}[h!]
				\begin{figcenter}
					\input{images/evaluation/plot-times-pattern-datasets.py_import.pgf}
				\end{figcenter}
				\caption{Total graph generation times for all three pattern-based dataset categories.}
				\label{fig:eval-import-pattern-abs}
			\end{figure}
			
			\begin{figure}[h!]
				\begin{figcenter}
					\input{images/evaluation/pattern-based-maze/plot-import-details-per-vertices.py_absolute-relative.pgf}
				\end{figcenter}
				\caption{Tasks during graph generation using the maze dataset in absolute time (left) and relative share on the total time (right). The kNN search determines the total processing time covering the data points for the total time.}
				\label{fig:eval-import-pattern-maze-abs-rel}
			\end{figure}
		
		\subsubsection{Routing}
		
			Because the pattern-based datasets did not contain any roads, the time required for routing solely depended on the size of the visibility graph and therefore on the time required to connect the source and destination vertices, which is the main task during routing.
			This task uses parts of the graph generation algorithm and therefore its runtime also increases quadratically with the number of vertices in the graph.
			
			The A* algorithm uses this quadratically growing graph and therefore shows a quadratic runtime, too.
			However, this quadratic runtime is not clearly visible in the data and a linear regression of the maze- and rectangle-based datasets yield an similarly good correlation.
			The effect of a quadratic complexity might therefore be significant in even larger datasets.
			
			\begin{figure}[h!]
				\hspace{-20pt}
				\input{images/evaluation/plot-times-pattern-datasets.py_routing.pgf}
				\caption{Routing time between the longest distant waypoints in each pattern-based dataset.}
				\label{fig:eval-pattern-routing-details}
			\end{figure}
		
	\subsection{Optimizations}
	
		The impact of the optimizations presented in \Cref{chap:implementation} was measured using the 0.5km\textsuperscript{2} \enquote{OSM city} dataset and disabling each optimization as shown in \Cref{table:optimization-impact}.
		
		\begin{table}[h]
			\begin{figcenter}
				\begin{tabularx}{11cm}{p{4.5cm}RR}
\toprule
\textbf{Disabled optimizations}				& \textbf{Import time}	& \textbf{Increase factor}	\\
\midrule
Shadow areas								& 104.2s 				& 10.63						\\
kNN filtering								&  10.7s				&  1.09						\\
Vertices on convex hull						&  17.6s				&  1.80						\\
Valid angle areas							&  11.9s				&  1.22						\\
Custom collision detection					&  10.7s				&  1.09						\\
\midrule
All											& 739.9s 				& 75.44						\\
None										&   9.8s				&  1.00						\\
\bottomrule
				\end{tabularx}
			\end{figcenter}
			\caption{Impact of each optimization on the 0.5km\textsuperscript{2} \enquote{OSM city} dataset import.}
			\label{table:optimization-impact}
		\end{table}
		
		Especially noteworthy is the 75 times longer import time when deactivating all optimizations, which is more than the product of all other increase factors together.
		This is due to the mutual influence of the deactivated optimizations leading to more visibility checks, which result in a proportionally higher processing time.
		
		Considering the optimizations separately, the shadow areas do have the strongest impact on reducing the processing time by about one order of magnitude.
		All other optimizations have a smaller impact with factors of under 2, which still adds up to a significant increase in performance.
		
\section{Route correctness and quality}

	\subsection{Weight function}
	
		Before the correctness and quality of the routes are discussed, a brief introduction into the weight function is given.
		When determining true shortest paths, the length of an edge is its weight, which should be minimized in order to obtain the shortest path.
		Whenever certain edges should be preferred or avoided, a factor is determined based on the edges attributes.
		Due to the minimization algorithm a factor lower one means an edge is preferred, a factor greater one rather avoids those edges.
		A factor of positive infinity on an edge $e$ completely avoids this edge since any other path has a lower total weight than a path containing $e$.
		
		The implementation of the hybrid visibility graph provides three routing methods.
		One determined the true shortest path (all weight factors are one), one determines a weighted path (factor of 0.8 for road edges) and one accepts a custom weight function.
		
		All following analyses use the predefined weight function with a factor of 0.8 on road edges.
		Determining true shortest paths would not use any road edges, except a road edge is itself a visibility edge.
		The influence of this weight factor on road edges is discussed in the following sections.

	\subsection{Correctness}
	\label{subsec:correctness}
	
		% is the shortest route really the shortest
		The hybrid routing algorithm is considered \emph{correct} if the resulting path between any two given locations is the shortest possible path with respect to the obstacled of the dataset.
		Edges on a visibility graph, which was constructed using vertices from obstacles in the plain, represents shortest segments between vertices of obstacles.
		In other words, for any two vertices $v$ and $v'$, the edge $e$ from the visibility graph is the shortest possible connection between these two vertices without intersecting with any obstacle.
		A shortest path through a visibility graph is therefore equal to a shortest geometric path around obstacles in the plain.
		
		For shortest paths algorithms, such as A* or Dijkstra, the term \emph{correct} refers to the fact that their result is the shortest possible path between two vertices in a graph.
		The correctness of the hybrid routing algorithm presented in this thesis is identical to this and follows from the argumentation above.
		
		In addition to routing on a visibility graph, the presented hybrid routing algorithm actively connects locations to the graph as part of answering the routing query yielding a temporarily augmented graph.
		This means the resulting path $p$ from vertex $s$ to $t$ contains two additional edges $(s, v_s)$ and $(v_t, t)$, which are not part of the normal hybrid visibility graph, resulting in $p=\left\langle s, v_s, ..., v_t, t \right\rangle$.
		These two additional edges are visibility edges and the correctness argument applies to them as well, meaning that the overall path $p$ is shortest on the augmented visibility graph and therefore shortest in the geometric domain of obstacles in the plain.
		
		Two aspects are noteworthy in the context of correctness.
		
		First, the A* implementation of MARS accepts other weight functions than the default \enquote{shortest}-function.
		This is also possible in the hybrid routing algorith when calling the \texttt{OptimalPath} method, which accepts a \texttt{Func} delegate as weight function.
		
		Second, filtering the potential visibility neighbors to get the $k$ nearest neighbors, as described in \Cref{subsec:step-2-knn-search}, might result in missing edges.
		This has a direct effect on the quality of the resulting paths since they may not be optimal anymore.
		However, the default parameter (36 bins covering 10° each and containing up to 10 neighbors) result in 5.42\% less visibility edges in the 0.5km\textsuperscript{2} \enquote{OSM city} dataset.
		No detours occurred during any routing analysis, which indicates the low significance of these removed edges.
		
	\subsection{Quality of routes}
	
		\subsubsection{Route quality definition and determination}
	
			The quality of a route does not only refer to a mathematical metric, but also to a more subjective quality of routes.
			However, subjective as well as mathematical metrics are consideres in this quality analysis.
			
			An ideal route, meaning a route of maximum quality, would exactly match a manually chosen expected path.
			This expected paths used in the following sections were determined using aerial imagery, local knowledge and the data contained in OSM.
			Therefore, an expected path is realistically walkable in the real world and would likely be chosen by actual pedestrians.
			This also means that an expected path contains a certain subjective component, for example the exact place where the route changes to the other side of a road.
	
			The evaluation of the route quality is performed using two criterions.
			First, a manual analysis is performed using an expected path to compare a determined route against.
			Second, mathematical metrics are used to quantify the similarity between an expected and actual route.
		
		% How realistic are the routes (= can I go there in real life)? If not: Why not?
		\subsubsection{Manual route analysis}
		\label{subsubsec:manual-route-analysis}
		
			In the following examples, routes determined by graph-based routing and the hybrid routing algorithm are compared against an expected result.
			This expected route was created based on OpenStreetMap data, aerial imagery and also local knowledge.
			It was \emph{not} created to intentionally match the results from the hybrid routing algorithm.
		
			% From motivation
			The first situation shows a small square at the subway station \enquote{Osterstraße} in Hamburg, Germany, which only exist as an mostly unconnected area not usable for graph-based algorithms.
			\Cref{fig:eval-osterstrasse-route-expected} shows the route between two POIs determined using Graphhopper.
			The result is unfortunate as it does not cross the square due to the lack of necessary edges needed by the routing algorithm.
			The hybrid routing algorithm, shown in \Cref{fig:eval-osterstrasse-actual-expected}, does not directly match the expected route but yielded a much closer and comparably good result.
			
			\begin{figure}[h!]
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\includegraphics[width=\textwidth]{images/qgis-routing-osterstrasse-expected-vs-routing}
						\end{figcenter}
						\caption{The graph-based routing result (red) and the expected route (blue). The red dotted parts are direct connections to the closest point on an edge.}
						\label{fig:eval-osterstrasse-route-expected}
					\end{subfigure}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\includegraphics[width=\textwidth]{images/qgis-routing-osterstrasse-expected-vs-actual}
						\end{figcenter}
						\caption{The result of the hybrid routing algorithm (green) and the expected route (blue).}
						\label{fig:eval-osterstrasse-actual-expected}
					\end{subfigure}
				\end{minipage}
				\caption{Comparison of a graph-based route (red; determined on \href{https://www.openstreetmap.org/directions?engine=fossgis\_osrm\_foot\&route=53.57657\%2C9.95210\%3B53.57601\%2C9.95268\#map=19/53.57632/9.95218}{osm.org}) with the hybrid routing algorithm (green) and the expected result (blue). The dashed part of the expected result is an equally good alternative route. The difficulty of this scenario is the traversal of the square \enquote{Fanny-Mendelssohn Platz}.}
				\label{fig:eval-osterstrasse}
			\end{figure}
			
			% Interesting passages from the city dataset
			Next to the above example and comparison to graph-based routing, an analysis of the routes determined within the 1km\textsuperscript{2} \enquote{OSM city} dataset yields some noteworthy findings.
			
			First, the quality of a route significantly decreases with missing or wrong data as visible in \Cref{fig:eval-city-usefulness-b} and \ref{fig:eval-city-usefulness-c}.
			The passages marked in red in these images are often shortcuts via private property.
			Those areas, however, are usually filled with obstacles such as fences, walls or different kinds of vegetation.
			As described in \Cref{subsubsec:data-not-in-osm}, private areas in OSM often contain very few to no details.
			
			Second, within densely built-up areas, larger open spaces are rare and the combination of roads and buildings form corrdidors in which routes tend to lie.
			When and how often the route determined by the hybrid routing algorithm follows a road depends on the weighting function.
			
			\clearpage
			\begin{figure}[h!]
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\includegraphics[width=\textwidth]{images/qgis-routing-city-routing-1}
						\end{figcenter}
						\caption{Simple route with only one small passage of missing data.}
						\label{fig:eval-city-usefulness-1}
					\end{subfigure}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\includegraphics[width=\textwidth]{images/qgis-routing-city-routing-3}
						\end{figcenter}
						\caption{Missing obstacles (mainly walls and fences between buildings) lead to non-realistic routes.}
						\label{fig:eval-city-usefulness-b}
					\end{subfigure}
				\end{minipage}
				\\[3ex]
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\includegraphics[width=\textwidth]{images/qgis-routing-city-routing-6}
						\end{figcenter}
						\caption{Missing walls, fences and hedges on private property are a common type of missing obstacles.}
						\label{fig:eval-city-usefulness-c}
					\end{subfigure}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\begin{figcenter}
							\includegraphics[width=\textwidth]{images/qgis-routing-city-routing-18}
						\end{figcenter}
						\caption{Cities with closed rows of buildings do not provide many degrees of freedom, which results in similar or even equal routes, regardles of the algorithm.}
						\label{fig:eval-city-usefulness-d}
					\end{subfigure}
				\end{minipage}
				\caption{Expected (green), graph-based (black) and hybrid routing algorithm results (blue) using the 1km\textsuperscript{2} city dataset. Unexpected parts due to missing or faulty data are marked in red.}
				\label{fig:eval-city-usefulness}
				\begin{minipage}[t]{.48\textwidth}
					\begin{figcenter}
						\includegraphics[width=\textwidth]{images/qgis-routing-city-roads}
					\end{figcenter}
					\caption{Two unrealistic road crossings (yellow) across a six-lane road.}
					\label{fig:eval-city-road-crossing}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{.48\textwidth}
					\begin{figcenter}
						\includegraphics[width=\textwidth]{images/qgis-routing-city-weights}
					\end{figcenter}
					\caption{Influence of weight factors. Lower value result in a stronger preference for roads.}
					\label{fig:eval-city-weights}
				\end{minipage}
			\end{figure}
			
			Third, large roads create instances of the aforementioned rare but wide obstacle-free areas, which, however, might result in unrealistic road crossings.
			Such situation can be seen in \Cref{fig:eval-city-road-crossing} with crossings over a six-lane road, which would be dangerous and unrealistic for real-world pedestrians.
			
			Forth, the weight function has a huge impact on the route quality.
			It specifies for example how strongly roads should be preferred, which is illustrated in \Cref{fig:eval-city-weights} with the same route using different weights for road edges.
			Adjusting and definiting fine-grained weight functions may help to imporove the routing behavior in some of the above mentioned situations.
			
			% Interesting passages from the rural dataset
			In the \enquote{OSM city} datasets with only smaller open areas, graph-based routes and routes determined by the hybrid routing algorithm were often similar and some parts even identical.
			Datasets with larger open areas and irregular distributed obstacles, as in the \enquote{OSM rural} datasets, can greatly benefit from the hybrid routing algorithm.
			
			Figures \Cref{fig:eval-rural-routing-6} and \ref{fig:eval-rural-graph-based-comparison} give some examples on routes in a rural area with large open spaces.
			Two findings can be inferred from the analysis of the rural routing results.
			
			First, the difference between graph-based routes and routes from the hybrid routing algorithm is significantly larger.
			In fact, routes might not share any location and graph-based routes tend to be significantly longer.
			This can be seen in \Cref{fig:eval-rural-graph-based-comparison-6} with a graph-based route of 1.73km while the expected result is only 0.67km long.
			\Cref{fig:eval-rural-graph-based-comparison-17} shows a similar behavior even though the difference in distance is smaller because the graph-based, expected and actual route share common parts.
			
			Second, the accuracy and therefore the usefulness for real-world applications (such as navigation apps) heavily relies on the amount of details in the dataset.
			\Cref{fig:eval-rural-routing-6-osm} illustrates the problem of missing data, which are in this case missing ditches within the farmland.
			The determined route has a length of 365m while the shortest possible route (determined using aerial imagery as seen in \Cref{fig:eval-rural-routing-6-aerial}) is 677m long.
			
			\begin{figure}[h!]
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\includegraphics[width=\textwidth]{images/qgis-routing-rural-routing-6-osm}
						\caption{The expected route differs significantly from the actual route taken by the agent. The dashed line is an alternative route under the assumption, that the farmland is reachable from the upper road.}
						\label{fig:eval-rural-routing-6-osm}
					\end{subfigure}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\includegraphics[width=\textwidth]{images/qgis-routing-rural-routing-6-aerial}
						\caption{Aerial imagery shows the amount of missing data, which in this case are numerous missing ditches in the arable land.}
						\label{fig:eval-rural-routing-6-aerial}
					\end{subfigure}
				\end{minipage}
				\caption{Routing on farmland illustrating the importance of correct data in the routing result showing the expected route (green) and actual path determined by the hybrid routing algorithm (green).}
				\label{fig:eval-rural-routing-6}
			\end{figure}
			
			\begin{figure}[h!]
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\includegraphics[width=\textwidth]{images/qgis-routing-rural-routing-6-graph-based}
						\caption{Same waypoints from \Cref{fig:eval-rural-routing-6} with the additional result of a graph-based routing request creating a 2.6 times longer path.}
						\label{fig:eval-rural-graph-based-comparison-6}
					\end{subfigure}
				\end{minipage}
				\hfill
				\begin{minipage}[t]{.48\textwidth}
					\begin{subfigure}[t]{\linewidth}
						\includegraphics[width=\textwidth]{images/qgis-routing-rural-routing-17-graph-based}
						\caption{Example of detours created by a graph-based routing algorithm even though the first part of the result is equal to the one of the hybrid routing algorithm. The shortcut of the actual result (horizontal part of the blue route) is a result of missing obstacles similar to the situation visible in \Cref{fig:eval-rural-routing-6-aerial}.}
						\label{fig:eval-rural-graph-based-comparison-17}
					\end{subfigure}
				\end{minipage}
				\caption{Comparison of graph-based routing results (red) with the expected route (green) and actual results (blue) of the hybrid routing algorithm.}
				\label{fig:eval-rural-graph-based-comparison}
			\end{figure}
		
		\subsubsection{Mathematical route quality analysis}
		
			After a manual analysis of the route quality, mathematical approaches were used to obtain quantifiable results, which was done using two metrics.
			First, the beeline distance between two waypoints was compared to the distances of the corresponding expected route, the route based on the hybrid visibility graph and the route of graph-based routing.
			Second, the similarity of routes was determined to determine how well the results fit to the expected route
			Both comparisons were performed on the first ten routing requests of the OSM datasets.
			
			\begin{wrapfigure}{r}{0.35\textwidth}
				\vspace{-1\baselineskip}
				\begin{figcenter}
					\begin{tikzpicture}
					[
						every node/.append style={outer sep=0.5mm, inner sep=0}
					]
						\def\d{0.75}
						
						\node (c00) at (0.5*\d ,0) {};
						\node (c01) at (1*\d   ,1*\d) {};
						\node (c02) at (0.15*\d ,2*\d) {};
						\node (c03) at (0.55*\d,3*\d) {};
						\node (c04) at (0      ,4*\d) {};
						
						\node (c10) at (2*\d  ,0.15) {};
						\node (c11) at (2.1*\d,0.9*\d) {};
						\node (c12) at (1.25*\d,1.8*\d) {};
						\node (c13) at (3*\d  ,2.8*\d) {};
						\node (c14) at (1.2*\d,4.15*\d) {};
						
						\draw (c00.center) -- (c01.center) -- (c02.center) -- (c03.center) -- (c04.center);
						\draw (c10.center) -- (c11.center) -- (c12.center) -- (c13.center) -- (c14.center);
						
						\draw[>=stealth',<->,densely dotted] (c00) -- (c10);
						\draw[>=stealth',<->,densely dotted] (c01) -- (c11);
						\draw[>=stealth',<->,densely dotted] (c02) -- (c12);
						\draw[>=stealth',<->,thick,red] (c03) -- (c13);
						\draw[>=stealth',<->,densely dotted] (c04) -- (c14);
						
						% Enlarge BBOX to avoid cropping off some of the arrow heads:
						\node (bbox_a) at (-0.1,-0.1) {};
						\node (bbox_b) at (3*\d+0.1,4.15*\d+0.1) {};
					\end{tikzpicture}
				\end{figcenter}
				\caption{Hausdorff distance (red) between two linestrings.}
				\label{fig:hausdorff-distance}
			\end{wrapfigure}
			
			In \Cref{fig:eval-route-distances}, the distance factors show an important relation between the route distances.
			The mean value of both datasets indicate, that the average route from the hybrid routing algorithm is shorter and the average route of the graph-based routing is longer than the expected route.
			This is in line with the results of the previous manual route analysis, according to which missing data lead to unrealistic but shorter routes.
			The route length comparison also confirms the previous results, that graph-based routing leads to longer routes with sometimes significant detours, which can be seen in the routing requests 6 and 7 in \Cref{fig:eval-route-distances-rural}.
			
			\begin{figure}[h]
				\begin{subfigure}[t]{\linewidth}
					\begin{figcenter}
						\input{images/evaluation/similarity-metric/plot.py_osm-city_relative-beeline.pgf}
					\end{figcenter}
					\caption{\enquote{OSM city} dataset.}
					\label{fig:eval-route-distances-city}
				\end{subfigure}
				\\[3ex]
				\begin{subfigure}[t]{\linewidth}
					\begin{figcenter}
						\input{images/evaluation/similarity-metric/plot.py_osm-rural_relative-beeline.pgf}
					\end{figcenter}
					\caption{\enquote{OSM rural} dataset.}
					\label{fig:eval-route-distances-rural}
				\end{subfigure}
				\caption{Relative route distances compared to the beeline distance between the waypoints of each routing request using the 0.5km\textsuperscript{2} OSM datasets.}
				\label{fig:eval-route-distances}
			\end{figure}
			
			\begin{figure}[h]
				\begin{subfigure}[t]{\linewidth}
					\begin{figcenter}
						\input{images/evaluation/similarity-metric/plot.py_osm-city_hausdorff.pgf}
					\end{figcenter}
					\caption{\enquote{OSM city} dataset.}
					\label{fig:eval-hausdorff-city}
				\end{subfigure}
				\\[3ex]
				\begin{subfigure}[t]{\linewidth}
					\begin{figcenter}
						\input{images/evaluation/similarity-metric/plot.py_osm-rural_hausdorff.pgf}
					\end{figcenter}
					\caption{\enquote{OSM rural} dataset.}
					\label{fig:eval-hausdorff-rural}
				\end{subfigure}
				\caption{Hausdorff distances between the expected routes and the corresponding routes of the hybrid routing algorithm and graph-based routing using the 0.5km\textsuperscript{2} OSM datasets.}
				\label{fig:eval-hausdorff}
			\end{figure}
			
			The comparisons of route lengths only yield vague insights into the similarities of calculated to expected routes and therefore only give a first indication of the route's quality.
			In the following, results using the \term{Hausdorff distance} as a second metric will be presented.
			The Hausdorff distance can be used to quantify the similarity of two linestrings by determining the maximum distance between them, which is illustrated in \Cref{fig:hausdorff-distance}.
			
			\Cref{fig:eval-hausdorff} shows the results for both OSM datasets and yields some insights into the route similarities:
			\begin{itemize}
				\item In both datasets, the average Hausdorff distances of the routes determined using the hybrid routing algorithm are shorter than those of the graph-based algorithm.
				\item The difference is smaller in the city dataset, which supports the aforementioned hypothesis, that the buildings in a city create corridors leading to similar routes for graph-based and geometric routing algorithms.
				\item Except for the routing requests 6 and 7 in the \enquote{OSM rural} datasets, the Hausdorff distances of the routes by the hybrid routing algorithm tend to be larger than the distances of the graph-based routes.
				This is likely due to missing data as discussed in the previous section and illustrated in \Cref{fig:eval-rural-routing-6} leading to shorter but less realistic routes.
			\end{itemize}

		\subsubsection{Route quality analysis summary}
			
			The manual route analysis as well as both metrics, the comparison to the beeline distance and the Hausdorff distance, yield similar results regarding the quality of routes:
			
			\begin{itemize}
				\item The route quality heavily depends on the data quality.
				Missing data, for example some missing ditches on farmland, lead to shorter but unrealistic routes determined with the hybrid routing algorithm.
				\item Cities and densely built-up areas form corridors through with geometric- and graph-based routes tend to be very similar.
				\item Graph-based routes between waypoints in rural or remote areas might create long detours.
				Such detours often are unrealistic, especially in agent-based models simulating scenarios in which pedestrians do not respect access restrictions to private areas, such as in emergency or evacuation scenarios.
			\end{itemize}
			\noindent
			In scenarios with a high quality in data, for example when using official indoor room plans of buildings or when the data quality is manually ensured by surveying an area, then the hybrid routing algorithm will likely create high quality routes reflecting the behavior of real pedestrians.